---
layout: post
title: "Rust åŠ¨æ€åˆ†å‘"
date: 2025-05-20 15:44:00 +0800
categories: rust
---

```rust
use tracing::info;

use crate::daemon::monitors::PositionMonitor;
use crate::daemon::position_monitor::{
    monitor_position_retracement::RetracementMonitor, monitor_prosition_stop::TrendStopMonitor,
};
use crate::modules::position::get_position_info;

pub fn start_all_position_monitors(key_group: u32) {
    let result = get_position_info(None, None, Some(key_group));

    match result {
        Ok(position) => {
            if position.position_amt == "0.000" || position.side.is_empty() {
                info!("key_group {} å½“å‰ä¸ºç©ºä»“ï¼Œè·³è¿‡ç›‘æ§å¯åŠ¨", key_group);
                return;
            }
            info!("ğŸ“¡ å¯åŠ¨ä»·æ ¼traitå›æ’¤ç›‘æ§çº¿ç¨‹ï¼ˆç»„å· {}ï¼‰", key_group);

            let entry_price = position.entry_price.parse().unwrap_or(0.0);

            let monitors: Vec<Box<dyn PositionMonitor>> = vec![
                Box::new(TrendStopMonitor {
                    key_group,
                    side: position.side.clone(),
                }),
                Box::new(RetracementMonitor {
                    key_group,
                    side: position.side.clone(),
                    entry_price,
                }),
            ];

            for monitor in monitors {
                std::thread::spawn(move || {
                    if let Err(e) = monitor.run_monitor_loop() {
                        info!("ç›‘æ§é”™è¯¯: {:?}", e);
                    }
                });
            }
        }
        Err(e) => {
            info!("è·å–æŒä»“å¤±è´¥ï¼Œkey_group {}: {:?}", key_group, e);
        }
    }
}
```

---



è¿™æ®µä»£ç åˆ›å»ºäº†ä¸€ä¸ªåŒ…å«å¤šä¸ªå®ç°äº† `PositionMonitor` trait çš„ç›‘æ§å™¨çš„åŠ¨æ€æ•°ç»„ï¼ˆ`Vec<Box<dyn PositionMonitor>>`ï¼‰ï¼Œå¹¶é€šè¿‡ `Box::new` å°†å®ƒä»¬å°è£…æˆå †åˆ†é…çš„ trait å¯¹è±¡ã€‚ä»¥ä¸‹æ˜¯é€æ­¥è§£æï¼š

---

### **1. å®šä¹‰ `monitors` åŠ¨æ€æ•°ç»„**
```rust
let monitors: Vec<Box<dyn PositionMonitor>> = vec![
    Box::new(TrendStopMonitor { /* ... */ }),
    Box::new(RetracementMonitor { /* ... */ }),
];
```
- **`Vec<Box<dyn PositionMonitor>>`**  
  è¿™æ˜¯ä¸€ä¸ªåŠ¨æ€æ•°ç»„ï¼Œå­˜å‚¨çš„æ˜¯**å †åˆ†é…çš„ trait å¯¹è±¡**ï¼ˆ`Box<dyn PositionMonitor>`ï¼‰ï¼Œè¡¨ç¤ºæ•°ç»„ä¸­å¯ä»¥å­˜æ”¾ä»»ä½•å®ç°äº† `PositionMonitor` trait çš„ç±»å‹ã€‚
- **`Box::new`**  
  å°†å…·ä½“ç±»å‹çš„å®ä¾‹ï¼ˆå¦‚ `TrendStopMonitor`ï¼‰åˆ†é…åˆ°å †ä¸Šï¼Œå¹¶è½¬æ¢ä¸º `Box<dyn PositionMonitor>` ç±»å‹ï¼Œä»¥å®ç°åŠ¨æ€åˆ†å‘ã€‚

---

### **2. åˆå§‹åŒ–ç›‘æ§å™¨å®ä¾‹**
#### **(1) `TrendStopMonitor`**
```rust
Box::new(TrendStopMonitor {
    key_group,                  // ä¼ å…¥ key_groupï¼ˆu32ï¼‰
    side: position.side.clone(), // å…‹éš†æŒä»“æ–¹å‘ï¼ˆString æˆ– &strï¼‰
})
```
- ç”¨äºç›‘æ§è¶‹åŠ¿æ­¢æŸé€»è¾‘ã€‚
- åªéœ€ `key_group` å’Œ `side` ä¸¤ä¸ªå­—æ®µã€‚

#### **(2) `RetracementMonitor`**
```rust
Box::new(RetracementMonitor {
    key_group,                  // ä¼ å…¥ key_group
    side: position.side.clone(), // å…‹éš†æŒä»“æ–¹å‘
    entry_price,                // ä¼ å…¥ entry_priceï¼ˆf64ï¼‰
})
```
- ç”¨äºç›‘æ§ä»·æ ¼å›æ’¤é€»è¾‘ã€‚
- æ¯” `TrendStopMonitor` å¤šä¸€ä¸ª `entry_price` å­—æ®µã€‚

---

### **3. ä¸ºä»€ä¹ˆç”¨ `Box<dyn Trait>`ï¼Ÿ**
- **åŠ¨æ€åˆ†å‘ï¼ˆDynamic Dispatchï¼‰**  
  ç”±äº `Vec` è¦æ±‚æ‰€æœ‰å…ƒç´ ç±»å‹ç›¸åŒï¼Œä½† `TrendStopMonitor` å’Œ `RetracementMonitor` æ˜¯ä¸åŒç±»å‹ï¼Œé€šè¿‡ `Box<dyn PositionMonitor>` å°†å®ƒä»¬ç»Ÿä¸€è§†ä¸º trait å¯¹è±¡ï¼Œå®ç°è¿è¡Œæ—¶å¤šæ€ã€‚
- **æ‰€æœ‰æƒç®¡ç†**  
  `Box` ç¡®ä¿ç›‘æ§å™¨å®ä¾‹çš„ç”Ÿå‘½å‘¨æœŸç”±å †å†…å­˜ç®¡ç†ï¼Œé¿å…æ‚¬å‚æŒ‡é’ˆã€‚

---

### **4. `PositionMonitor` trait çš„ä½œç”¨**
å‡è®¾ `PositionMonitor` å®šä¹‰å¦‚ä¸‹ï¼ˆéœ€åœ¨ä½ çš„ä»£ç ä¸­å­˜åœ¨ï¼‰ï¼š
```rust
pub trait PositionMonitor {
    fn run_monitor_loop(&self) -> Result<(), BinanceError>;
}
```
- æ‰€æœ‰ç›‘æ§å™¨å¿…é¡»å®ç° `run_monitor_loop` æ–¹æ³•ã€‚
- åç»­çš„ `for monitor in monitors` å¯ä»¥ç»Ÿä¸€è°ƒç”¨è¯¥æ–¹æ³•ï¼Œæ— éœ€å…³å¿ƒå…·ä½“ç±»å‹ã€‚

---

### **5. ä»£ç æ‰§è¡Œæµç¨‹**
1. **åˆ›å»ºç›‘æ§å™¨åˆ—è¡¨**  
   - å°† `TrendStopMonitor` å’Œ `RetracementMonitor` å®ä¾‹æ”¾å…¥ `Vec`ã€‚
2. **å¯åŠ¨çº¿ç¨‹ç›‘æ§**  
   - éå† `monitors`ï¼Œä¸ºæ¯ä¸ªç›‘æ§å™¨å¯åŠ¨ä¸€ä¸ªç‹¬ç«‹çº¿ç¨‹ï¼š
     ```rust
     std::thread::spawn(move || {
         if let Err(e) = monitor.run_monitor_loop() {
             info!("ç›‘æ§é”™è¯¯: {:?}", e);
         }
     });
     ```
   - æ¯ä¸ªçº¿ç¨‹ä¼šæŒç»­è¿è¡Œ `run_monitor_loop()`ï¼Œç›´åˆ°å‡ºé”™æˆ–é€€å‡ºã€‚

---

### **å…³é”®ç‚¹æ€»ç»“**

| éƒ¨åˆ† | è¯´æ˜ |
|------|------|
| `Vec<Box<dyn PositionMonitor>>` | å­˜å‚¨å¤šç§ç›‘æ§å™¨çš„åŠ¨æ€æ•°ç»„ |
| `Box::new(TrendStopMonitor { ... })` | å°†å…·ä½“ç±»å‹å°è£…ä¸º trait å¯¹è±¡ |
| `position.side.clone()` | å…‹éš† `side` é¿å…æ‰€æœ‰æƒé—®é¢˜ |
| `std::thread::spawn` | ä¸ºæ¯ä¸ªç›‘æ§å™¨å¯åŠ¨ç‹¬ç«‹çº¿ç¨‹ |
{:.markdown-table}
---

### **ç±»æ¯”ç†è§£**
æƒ³è±¡æˆä¸€ä¸ª**å¤šè®¾å¤‡æ§åˆ¶ä¸­å¿ƒ**ï¼š
- `PositionMonitor` æ˜¯â€œè®¾å¤‡æ¥å£â€ï¼ˆå¦‚æ”¯æŒ `start()` æ–¹æ³•ï¼‰ã€‚
- `TrendStopMonitor` å’Œ `RetracementMonitor` æ˜¯ä¸¤ç§ä¸åŒçš„è®¾å¤‡ï¼ˆå¦‚â€œæ¸©åº¦ä¼ æ„Ÿå™¨â€å’Œâ€œæ¹¿åº¦ä¼ æ„Ÿå™¨â€ï¼‰ã€‚
- `Vec<Box<dyn PositionMonitor>>` æ˜¯è®¾å¤‡åˆ—è¡¨ï¼Œå¯ä»¥ç»Ÿä¸€ç®¡ç†å®ƒä»¬ã€‚

---

### **æ”¹è¿›å»ºè®®**
1. **é¿å…å…‹éš† `side`**  
   å¦‚æœ `side` æ˜¯ `&str` æˆ–èƒ½å€Ÿç”¨ï¼Œæ”¹ç”¨ `Cow<'_, str>` æˆ– `&str` å‡å°‘æ‹·è´ã€‚
2. **é”™è¯¯å¤„ç†**  
   `entry_price.parse()` ç›´æ¥ `unwrap_or(0.0)` å¯èƒ½éšè—é”™è¯¯ï¼Œå»ºè®®ç”¨ `?` æå‰è¿”å›ã€‚
3. **çº¿ç¨‹ç®¡ç†**  
   ä¿å­˜ `JoinHandle` ä»¥ä¾¿åç»­ç­‰å¾…çº¿ç¨‹ç»“æŸï¼š
   ```rust
   let handles: Vec<_> = monitors.into_iter().map(|monitor| {
       std::thread::spawn(move || {
           monitor.run_monitor_loop().unwrap_or_else(|e| info!("ç›‘æ§é”™è¯¯: {:?}", e));
       })
   }).collect();
   ```

è¿™æ ·è®¾è®¡æ—¢çµæ´»ï¼ˆæ”¯æŒå¤šç§ç›‘æ§å™¨ï¼‰åˆç±»å‹å®‰å…¨ï¼ˆé€šè¿‡ trait çº¦æŸï¼‰ã€‚
  

This code creates a dynamic array (`Vec<Box<dyn PositionMonitor>>`) of monitors that implement the `PositionMonitor` trait, and encapsulates them into heap-allocated trait objects via `Box::new`. Here is a step-by-step breakdown:

---

### **1. Define the `monitors` dynamic array**
```rust
let monitors: Vec<Box<dyn PositionMonitor>> = vec![
Box::new(TrendStopMonitor { /* ... */ }),
Box::new(RetracementMonitor { /* ... */ }),
];
```
- **`Vec<Box<dyn PositionMonitor>>`**
This is a dynamic array that stores **heap-allocated trait objects** (`Box<dyn PositionMonitor>`), which means that any type that implements the `PositionMonitor` trait can be stored in the array.
- **`Box::new`**
Allocate instances of specific types (such as `TrendStopMonitor`) to the heap and convert them to `Box<dyn PositionMonitor>` type for dynamic distribution.

---

### **2. Initialize monitor instance**
#### **(1) `TrendStopMonitor`**
```rust
Box::new(TrendStopMonitor {
key_group, // pass in key_group (u32)
side: position.side.clone(), // clone position direction (String or &str)
})
```
- Used to monitor trend stop loss logic.
- Only two fields are needed: `key_group` and `side`.

#### **(2) `RetracementMonitor`**
```rust
Box::new(RetracementMonitor {
key_group, // pass in key_group
side: position.side.clone(), // clone position direction
entry_price, // pass in entry_priceï¼ˆf64ï¼‰
})
```
- Used to monitor price retracement logic.
- One more `entry_price` field than `TrendStopMonitor`.

---

### **3. Why use `Box<dyn Trait>`? **
- **Dynamic Dispatch**
Since `Vec` requires all elements to be of the same type, but `TrendStopMonitor` and `RetracementMonitor` are of different types, `Box<dyn PositionMonitor>` is used to treat them as trait objects to achieve runtime polymorphism.
- **Ownership management**
`Box` ensures that the lifecycle of the monitor instance is managed by heap memory to avoid dangling pointers.

---

### **4. The role of the `PositionMonitor` trait**
Assume that `PositionMonitor` is defined as follows (it must exist in your code):
```rust
pub trait PositionMonitor {
fn run_monitor_loop(&self) -> Result<(), BinanceError>;
}
```
- All monitors must implement the `run_monitor_loop` method.
- Subsequent `for monitor in monitors` can call this method uniformly without caring about the specific type.

---

### **5. Code execution flow**
1. **Create a monitor list**
- Put `TrendStopMonitor` and `RetracementMonitor` instances into `Vec`.
2. **Start thread monitoring**
- Traverse `monitors` and start a separate thread for each monitor:
```rust
std::thread::spawn(move || {
if let Err(e) = monitor.run_monitor_loop() {
info!("Monitor error: {:?}", e);
}
});
```
- Each thread will continue to run `run_monitor_loop()` until an error or exit.

---

### **Key Points**

| Section | Description |
|------|------|
| `Vec<Box<dyn PositionMonitor>>` | Dynamic array for storing multiple monitors |
| `Box::new(TrendStopMonitor { ... })` | Encapsulate specific types as trait objects |
| `position.side.clone()` | Clone `side` to avoid ownership issues |
| `std::thread::spawn` | Start a separate thread for each monitor |
{:.markdown-table}
---

### **Analogy**
Imagine a **multi-device control center**:
- `PositionMonitor` is a "device interface" (e.g. supports `start()` method).
- `TrendStopMonitor` and `RetracementMonitor` are two different devices (e.g. "temperature sensor" and "humidity sensor").
- `Vec<Box<dyn PositionMonitor>>` is a list of devices that can be managed in a unified way.

---

### **Improvement suggestions**
1. **Avoid cloning `side`**
If `side` is `&str` or can be borrowed, use `Cow<'_, str>` or `&str` to reduce copying.
2. **Error handling**
`entry_price.parse()` directly `unwrap_or(0.0)` may hide errors, it is recommended to use `?` to return in advance.
3. **Thread management**
Save `JoinHandle` to wait for the thread to end later:
```rust
let handles: Vec<_> = monitors.into_iter().map(|monitor| {
std::thread::spawn(move || {
monitor.run_monitor_loop().unwrap_or_else(|e| info!("Monitor error: {:?}", e));
})
}).collect();
```

This design is both flexible (supporting multiple monitors) and type-safe (through trait constraints).
---
layout: post
title: "Rust trait"
date: 2025-05-10 06:24:00 +0800
categories: rust

---

```yml
ä¸ºå…¶å®ç°äº†'ManageConnection' trait", è¿™ä¸ªtraitæˆ‘ä¸ç†è§£ï¼Œå¯ä»¥è¯´æ˜¯ç‰¹æ€§çš„æ„æ€å—?
```    


åœ¨ Rust ä¸­ï¼Œ`trait` ç¡®å®å¯ä»¥ç†è§£ä¸º **â€œç‰¹æ€§â€** æˆ– **â€œæ¥å£â€**ï¼ˆç±»ä¼¼å…¶ä»–è¯­è¨€ä¸­çš„ `interface`ï¼‰ï¼Œä½†å®ƒçš„åŠŸèƒ½æ›´å¼ºå¤§ã€‚æ‚¨æåˆ°çš„ `ManageConnection` trait æ˜¯æ•°æ®åº“è¿æ¥æ± ï¼ˆå¦‚ `r2d2` æˆ– `deadpool`ï¼‰çš„æ ¸å¿ƒæŠ½è±¡ï¼Œä¸‹é¢æˆ‘ä¼šç”¨é€šä¿—æ˜“æ‡‚çš„æ–¹å¼è§£é‡Šï¼š

---

### 1. `trait` çš„æœ¬è´¨
- **æ˜¯ä»€ä¹ˆ**ï¼š`trait` å®šä¹‰äº†ä¸€ç»„ç±»å‹å¿…é¡»å®ç°çš„è¡Œä¸ºï¼ˆæ–¹æ³•ï¼‰ã€‚
- **ç±»æ¯”**ï¼š
  - åƒ Java çš„ `interface`ï¼ˆå®šä¹‰æ–¹æ³•ç­¾åï¼‰
  - åƒ TypeScript çš„ `interface`ï¼ˆä½†æ›´å¼ºå¤§ï¼‰
  - åƒ C++ çš„æŠ½è±¡ç±»ï¼ˆä½†æ²¡æœ‰æˆå‘˜å˜é‡ï¼‰

---

### 2. `ManageConnection` Trait çš„ä½œç”¨
ä»¥ `r2d2-redis` ä¸ºä¾‹ï¼š
```rust
// ç®€åŒ–çš„ trait å®šä¹‰
pub trait ManageConnection {
    type Connection;  // å…³è”ç±»å‹ï¼ˆè¡¨ç¤ºè¿æ¥çš„ç±»å‹ï¼Œå¦‚ RedisConnectionï¼‰
    type Error;       // å…³è”ç±»å‹ï¼ˆè¡¨ç¤ºå¯èƒ½çš„é”™è¯¯ï¼‰

    // å¿…é¡»å®ç°çš„æ–¹æ³•
    fn connect(&self) -> Result<Self::Connection, Self::Error>;
    fn is_valid(&self, conn: &mut Self::Connection) -> bool;
    fn has_broken(&self, conn: &mut Self::Connection) -> bool;
}
```

---

### 3. ä¸ºä»€ä¹ˆéœ€è¦è¿™ä¸ª Traitï¼Ÿ
è¿æ¥æ± ï¼ˆå¦‚ `RedisPool`ï¼‰éœ€è¦ç»Ÿä¸€ç®¡ç†ä¸åŒç±»å‹çš„æ•°æ®åº“è¿æ¥ï¼ˆMySQLã€Redisã€PostgreSQL ç­‰ï¼‰ã€‚é€šè¿‡ `ManageConnection`ï¼š
- **æŠ½è±¡å…±æ€§**ï¼šæ‰€æœ‰è¿æ¥ç±»å‹å¿…é¡»å®ç°è¿æ¥ã€éªŒè¯ç­‰æ–¹æ³•ã€‚
- **è§£è€¦**ï¼šè¿æ¥æ± ä¸éœ€è¦å…³å¿ƒå…·ä½“çš„è¿æ¥å®ç°ç»†èŠ‚ã€‚

---

### 4. å…·ä½“åˆ° `RedisConnectionManager`
`r2d2-redis` åº“ä¼šä¸º Redis å®ç°è¿™ä¸ª traitï¼š
```rust
impl ManageConnection for RedisConnectionManager {
    type Connection = redis::Connection;
    type Error = redis::RedisError;

    fn connect(&self) -> Result<Self::Connection, Self::Error> {
        // å®é™…åˆ›å»º Redis è¿æ¥çš„ä»£ç 
        redis::Client::open(self.connection_info)?.get_connection()
    }

    fn is_valid(&self, conn: &mut Self::Connection) -> bool {
        // æ£€æŸ¥è¿æ¥æ˜¯å¦æœ‰æ•ˆ
        redis::cmd("PING").query(conn).is_ok()
    }

    // ...å…¶ä»–æ–¹æ³•å®ç°
}
```

---

### 5. å®Œæ•´å·¥ä½œæµç¨‹
1. **å®šä¹‰ Trait**ï¼šåº“ä½œè€…å®šä¹‰ `ManageConnection`ï¼Œå£°æ˜éœ€è¦å“ªäº›æ–¹æ³•ã€‚
2. **å®ç° Trait**ï¼š`RedisConnectionManager` å®ç°è¿™äº›æ–¹æ³•ã€‚
3. **ä½¿ç”¨ Trait**ï¼šè¿æ¥æ± é€šè¿‡ `ManageConnection` çš„æ–¹æ³•ç®¡ç†è¿æ¥ã€‚

```rust
let pool = Pool::builder()
    .build(RedisConnectionManager::new("redis://localhost")?);
// æ± å†…éƒ¨è°ƒç”¨ manager.connect() ç­‰æ–¹æ³•
```

---

### å…³é”®æ¦‚å¿µå¯¹æ¯”
<table>
  <thead>
    <tr>
      <th>æœ¯è¯­</th>
      <th>è§£é‡Š</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><b>Trait</b></td>
      <td>è¡Œä¸ºè§„èŒƒï¼ˆâ€œèƒ½åšä»€ä¹ˆâ€ï¼‰</td>
    </tr>
    <tr>
      <td><b>Impl Trait</b></td>
      <td>ä¸ºå…·ä½“ç±»å‹å®ç°è¿™äº›è¡Œä¸ºï¼ˆâ€œæ€ä¹ˆåšâ€ï¼‰</td>
    </tr>
    <tr>
      <td><b>å…³è”ç±»å‹</b></td>
      <td>Trait ä¸­å®šä¹‰çš„ç±»å‹å ä½ç¬¦ï¼ˆå¦‚ <code>type Connection</code>ï¼‰ï¼Œç”±å®ç°è€…æŒ‡å®šå…·ä½“ç±»å‹</td>
    </tr>
  </tbody>
</table>

<style>
  table {
    width: 100%;
    border-collapse: collapse;
  }
  th, td {
    padding: 8px;
    text-align: left;
    border-bottom: 1px solid #ddd;
  }
  th {
    background-color: #f2f2f2;
  }
  code {
    font-family: monospace;
  }
</style>

---

### ä¸ºä»€ä¹ˆå« â€œTraitâ€ è€Œä¸æ˜¯ â€œInterfaceâ€ï¼Ÿ
Rust çš„ `trait` æ›´å¼ºå¤§ï¼š
- æ”¯æŒé»˜è®¤æ–¹æ³•å®ç°
- æ”¯æŒå…³è”ç±»å‹å’Œå¸¸é‡
- æ”¯æŒåŠ¨æ€åˆ†å‘ï¼ˆ`dyn Trait`ï¼‰
- å¯ç”¨äºè¿ç®—ç¬¦é‡è½½ï¼ˆå¦‚ `Add` traitï¼‰

---

### å®é™…ç±»æ¯”
æƒ³è±¡ä¸€ä¸ª **USB æ¥å£æ ‡å‡†**ï¼ˆTraitï¼‰ï¼š
- è§„å®šæ‰€æœ‰è®¾å¤‡å¿…é¡»èƒ½ä¼ è¾“æ•°æ®ï¼ˆæ–¹æ³•ï¼‰
- é¼ æ ‡/é”®ç›˜/Uç›˜ï¼ˆå…·ä½“ç±»å‹ï¼‰å„è‡ªå®ç°ä¼ è¾“é€»è¾‘
- ç”µè„‘ï¼ˆè¿æ¥æ± ï¼‰é€šè¿‡æ ‡å‡†æ¥å£ç»Ÿä¸€ç®¡ç†è®¾å¤‡

  
  


---
```yml
impl ManageConnection for RedisConnectionManager {ï¼Œè¿™å¥ä¸­çš„ManageConnectionï¼Œæ˜¯æ¥è‡ªäºuse r2d2::{ManageConnectionï¼Œè¿™é‡Œä¼ å…¥çš„ï¼Œä¸æ˜¯è‡ªå®šä¹‰çš„æ˜¯å§
```
---

æ‚¨è§‚å¯Ÿå¾—å¾ˆå‡†ç¡®ï¼åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`ManageConnection` **ä¸æ˜¯è‡ªå®šä¹‰çš„ trait**ï¼Œè€Œæ˜¯æ¥è‡ªäº `r2d2` åº“çš„é¢„å®šä¹‰ traitã€‚ä»¥ä¸‹æ˜¯è¯¦ç»†è§£é‡Šï¼š

---

### 1. **æ¥æºè¯´æ˜**
```rust
use r2d2::{ManageConnection}; // ä» r2d2 åº“å¯¼å…¥
```
- `ManageConnection` æ˜¯ `r2d2` è¿æ¥æ± åº“å®šä¹‰çš„ **æ ‡å‡† trait**ï¼ˆç±»ä¼¼æ¥å£ï¼‰
- æ‚¨éœ€è¦ä¸ºæ‚¨çš„è¿æ¥ç®¡ç†å™¨ï¼ˆå¦‚ `RedisConnectionManager`ï¼‰å®ç°è¿™ä¸ª traitï¼Œè€Œä¸æ˜¯è‡ªå®šä¹‰å®ƒ

---

### 2. **ä¸ºä»€ä¹ˆä½¿ç”¨åº“çš„ traitï¼Ÿ**
è¿™æ˜¯ Rust çš„ **"é¢å‘æ¥å£ç¼–ç¨‹"** è®¾è®¡ï¼š
- **`r2d2::Pool` åªè¦æ±‚**ï¼š  
  "ç»™æˆ‘ä»»ä½•å®ç°äº† `ManageConnection` çš„ç±»å‹ï¼Œæˆ‘éƒ½èƒ½ç®¡ç†å®ƒçš„è¿æ¥"
- **æ‚¨çš„å·¥ä½œ**ï¼š  
  é€šè¿‡ `impl ManageConnection for YourManager` å‘Šè¯‰ `r2d2`ï¼š"æˆ‘çš„ `RedisConnectionManager` ç¬¦åˆä½ çš„æ ‡å‡†"

---

### 3. å¯¹æ¯”è‡ªå®šä¹‰ trait
<table>
  <thead>
    <tr>
      <th>åœºæ™¯</th>
      <th>ä»£ç ç¤ºä¾‹</th>
      <th>è¯´æ˜</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><b>ä½¿ç”¨åº“çš„ trait</b></td>
      <td><code>impl ManageConnection for X</code></td>
      <td>å®ç°ç°æœ‰è§„èŒƒï¼ˆå¦‚æ•°æ®åº“è¿æ¥æ± ï¼‰</td>
    </tr>
    <tr>
      <td><b>è‡ªå®šä¹‰ trait</b></td>
      <td><code>trait MyTrait { ... }</code></td>
      <td>å®šä¹‰è‡ªå·±çš„è¡Œä¸ºæŠ½è±¡</td>
    </tr>
  </tbody>
</table>

<style>
  table {
    width: 100%;
    border-collapse: collapse;
  }
  th, td {
    padding: 8px;
    text-align: left;
    border-bottom: 1px solid #ddd;
  }
  th {
    background-color: #f2f2f2;
  }
  code {
    font-family: monospace;
  }
</style>

---

### 4. `r2d2` ä¸­çš„åŸå§‹å®šä¹‰
ï¼ˆç®€åŒ–ç‰ˆï¼Œå®é™…æºç æ›´å¤æ‚ï¼‰
```rust
// r2d2 åº“ä¸­å®šä¹‰çš„ trait
pub trait ManageConnection {
    type Connection;  // å…³è”ç±»å‹ï¼šè¿æ¥ç±»å‹
    type Error;       // å…³è”ç±»å‹ï¼šé”™è¯¯ç±»å‹

    fn connect(&self) -> Result<Self::Connection, Self::Error>;
    fn is_valid(&self, conn: &mut Self::Connection) -> bool;
    // ...å…¶ä»–å¿…è¦æ–¹æ³•
}
```

---

### 5. æ‚¨çš„å®ç°è§’è‰²
```rust
impl ManageConnection for RedisConnectionManager {
    type Connection = redis::Connection;  // æŒ‡å®šå…·ä½“ç±»å‹
    type Error = redis::RedisError;      // æŒ‡å®šé”™è¯¯ç±»å‹

    fn connect(&self) -> Result<Self::Connection, Self::Error> {
        self.client.get_connection() // å®é™…å®ç°
    }
    // ...å…¶ä»–æ–¹æ³•å®ç°
}
```
ç›¸å½“äºåœ¨è¯´ï¼š  
"æˆ‘ï¼ˆ`RedisConnectionManager`ï¼‰å®Œå…¨éµå®ˆ `r2d2` åˆ¶å®šçš„ã€Šè¿æ¥ç®¡ç†è§„èŒƒã€‹ï¼ˆ`ManageConnection`ï¼‰"

---

### å…³é”®ç»“è®º
- âœ… `ManageConnection` æ˜¯ `r2d2` çš„ **æ ‡å‡† trait**ï¼Œä¸æ˜¯æ‚¨è‡ªå®šä¹‰çš„
- âœ… æ‚¨çš„ä»»åŠ¡æ˜¯ **å®ç°å®ƒ**ï¼ˆå¡«ç©ºï¼‰ï¼Œè€Œä¸æ˜¯å®šä¹‰å®ƒ
- âœ… è¿™ç§æ¨¡å¼åœ¨ Rust ç”Ÿæ€ä¸­éå¸¸å¸¸è§ï¼ˆå¦‚ `Serde` çš„ `Serialize`/`Deserialize`ï¼‰

è¿™ç§è®¾è®¡è®©åº“ï¼ˆå¦‚ `r2d2`ï¼‰èƒ½å®šä¹‰é€šç”¨æ¥å£ï¼Œè€Œç”¨æˆ·å¯ä»¥ä¸ºå„ç§æ•°æ®åº“ï¼ˆRedis/MySQLç­‰ï¼‰æä¾›å…·ä½“å®ç°ï¼Œå®ç°é«˜åº¦è§£è€¦ã€‚

<br>
```yml
pub fn parse\<T: FromStr>(\&self) -> Result\<T, T::Err>,æƒ³è¿™äº›è¯­å¥çš„Tè¡¨ç¤ºä»€ä¹ˆï¼ŸFromStræ˜¯ä¸è¡¨ç¤ºä¸€ä¸ªç»“æ„ä½“ï¼Ÿ
```
<br>

éå¸¸æ£’çš„é—®é¢˜ï¼Œæ¶‰åŠåˆ°äº† **æ³›å‹ï¼ˆ`T`ï¼‰** å’Œ **traitï¼ˆå¦‚ `FromStr`ï¼‰** çš„æ ¸å¿ƒæ¦‚å¿µã€‚ä¸‹é¢æˆ‘ä»¬æ¥é€æ­¥è§£é‡Šä½ é—®çš„ä¸¤ä¸ªç‚¹ï¼š

---

## âœ… `T` è¡¨ç¤ºä»€ä¹ˆï¼Ÿ

```rust
pub fn parse<T: FromStr>(&self) -> Result<T, T::Err>
```

è¿™é‡Œçš„ `T` æ˜¯ä¸€ä¸ª**æ³›å‹ç±»å‹å‚æ•°**ï¼Œå®ƒçš„æ„æ€æ˜¯ï¼š

> â€œä½ æƒ³æŠŠè¿™ä¸ªå­—ç¬¦ä¸²è§£ææˆä»€ä¹ˆç±»å‹ï¼Œå°±æŠŠ `T` è®¾ç½®æˆé‚£ä¸ªç±»å‹ã€‚â€

ä¾‹å¦‚ï¼š

```rust
let x: i32 = "42".parse().unwrap();   // æ­¤æ—¶ T = i32
let y: f64 = "3.14".parse().unwrap(); // æ­¤æ—¶ T = f64
let b: bool = "true".parse().unwrap(); // æ­¤æ—¶ T = bool
```

ä½ è°ƒç”¨ `.parse()` çš„æ—¶å€™ï¼ŒRust ä¼šæ ¹æ®ç›®æ ‡å˜é‡ç±»å‹è‡ªåŠ¨æ¨æ–­ `T`ã€‚

---

## âœ… `FromStr` æ˜¯ä»€ä¹ˆï¼Ÿ

`FromStr` ä¸æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œè€Œæ˜¯ä¸€ä¸ª**traitï¼ˆç‰¹å¾ï¼‰**ï¼Œä¹Ÿå°±æ˜¯ä¸€ç»„è¡Œä¸ºçš„å®šä¹‰ã€‚

```rust
pub trait FromStr {
    type Err;
    fn from_str(s: &str) -> Result<Self, Self::Err>;
}
```

å®ƒçš„æ„æ€æ˜¯ï¼š

> â€œä»»ä½•å®ç°äº† `FromStr` çš„ç±»å‹ï¼Œéƒ½å¯ä»¥é€šè¿‡å­—ç¬¦ä¸²è§£æå‡ºæ¥ã€‚â€

ä¾‹å¦‚ï¼š

* `i32`ã€`f64`ã€`bool` éƒ½å®ç°äº† `FromStr`
* ä½ ä¹Ÿå¯ä»¥ç»™ä½ è‡ªå·±çš„ç±»å‹å®ç° `FromStr`

---

## âœ… ç›´è§‚ç†è§£ `T: FromStr`

```rust
<T: FromStr>
```

è¿™æ˜¯ä¸€ç§**çº¦æŸæ¡ä»¶**ï¼Œè¡¨ç¤ºï¼š

> æ³›å‹ `T` å¿…é¡»å®ç°äº† `FromStr`ï¼Œå¦åˆ™ä¸å…è®¸è°ƒç”¨ `.parse::<T>()`ã€‚

---

### ğŸ” æ€»ç»“ç±»æ¯”ï¼š

| æ¦‚å¿µ           | ç±»æ¯”ï¼ˆC++ / Java / ç±»å‹ç›´è§‰ï¼‰ | è¯´æ˜                         |
| ------------ | --------------------- | -------------------------- |
| `T`          | æ¨¡æ¿å‚æ•° / æ³›å‹å˜é‡           | å ä½ç±»å‹ï¼Œè°ƒç”¨æ—¶å…·ä½“åŒ–                |
| `FromStr`    | æ¥å£ / trait            | æä¾› `from_str()` çš„èƒ½åŠ›        |
| `T: FromStr` | T implements FromStr  | è¡¨ç¤º `T` æ‹¥æœ‰ `.from_str()` æ–¹æ³• |

---

è¦ä¸è¦æˆ‘ç»™ä½ å†™ä¸€ä¸ªç®€å•ä¾‹å­ï¼Œæ¼”ç¤ºå¦‚ä½•è‡ªå·±å®šä¹‰ä¸€ä¸ªç»“æ„ä½“å¹¶å®ç° `FromStr`ï¼Œç„¶åç”¨ `.parse()` è‡ªåŠ¨è½¬æ¢ï¼Ÿå¾ˆç›´è§‚ï¼

å¥½çš„ï¼ä¸‹é¢æˆ‘ä»¬æ¥å†™ä¸€ä¸ªå®Œæ•´ä¾‹å­ï¼š

---

## ğŸ¯ ç›®æ ‡

æˆ‘ä»¬è¦åˆ›å»ºä¸€ä¸ªç»“æ„ä½“ `Point`ï¼Œå®ƒè¡¨ç¤ºä¸€ä¸ªåæ ‡ `(x, y)`ï¼Œæ¯”å¦‚å­—ç¬¦ä¸² `"3,4"` å¯ä»¥è¢«è§£æä¸º `Point { x: 3, y: 4 }`ã€‚

---

## âœ… ä»£ç ç¤ºä¾‹

```rust
use std::str::FromStr;

#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

// ä¸º Point å®ç° FromStrï¼Œè¿™æ ·å°±å¯ä»¥ç”¨ "3,4".parse::<Point>()
impl FromStr for Point {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        // æ‹†åˆ†å­—ç¬¦ä¸²ï¼Œå½¢å¦‚ "3,4"
        let parts: Vec<&str> = s.split(',').collect();
        if parts.len() != 2 {
            return Err("æ ¼å¼å¿…é¡»æ˜¯ x,y".to_string());
        }

        let x = parts[0].trim().parse::<i32>().map_err(|_| "x è§£æå¤±è´¥")?;
        let y = parts[1].trim().parse::<i32>().map_err(|_| "y è§£æå¤±è´¥")?;

        Ok(Point { x, y })
    }
}

fn main() {
    let input = "3,4";
    let point: Point = input.parse().unwrap();

    println!("è§£æåçš„åæ ‡æ˜¯: {:?}", point);
}
```

---

## âœ… è¾“å‡ºç»“æœ

```txt
è§£æåçš„åæ ‡æ˜¯: Point { x: 3, y: 4 }
```

---

### âœ… å°ç»“

* `.parse()` å…¶å®å°±æ˜¯è°ƒç”¨ `T::from_str()`ï¼Œåªè¦ä½ ä¸º `T` å®ç°äº† `FromStr`ï¼Œå°±å¯ä»¥ç”¨å®ƒã€‚
* ä½ è‡ªå®šä¹‰çš„ç±»å‹ä¹Ÿå¯ä»¥æ”¯æŒ `.parse()`ï¼Œå…³é”®æ˜¯å®ç° `FromStr`ã€‚
* å®ç°æ—¶è®°å¾—è¿”å›ä¸€ä¸ª `Result<Self, Self::Err>`ï¼Œé”™è¯¯ç±»å‹è‡ªå·±å®šä¹‰ï¼ˆæ¯”å¦‚ç”¨ `String` æˆ– `Box<dyn Error>` éƒ½è¡Œï¼‰ã€‚

---

è¦ä¸è¦æˆ‘å†æ¼”ç¤ºä¸€ä¸ªæ›´å¤æ‚ç‚¹çš„ç‰ˆæœ¬ï¼Œæ¯”å¦‚ç”¨ `Result<Point, CustomError>` è‡ªå®šä¹‰é”™è¯¯ç±»å‹ï¼Ÿ
<br>
---
```yml
fn from\_str(s: \&str) -> Result\<Self, Self::Err> {ï¼Œä½ è¿™é‡Œåªå®šä¹‰äº†å‡½æ•°ï¼Œæ²¡çœ‹è§ä½ æœ‰è°ƒç”¨ï¼Œå²‚ä¸æ˜¯ç™½ç™½å®šä¹‰äº†
```

<br>
<br>
è¿™æ˜¯ä¸€ä¸ªéå¸¸ç»å…¸çš„ç–‘é—®ï¼ä½ è§‚å¯Ÿå¾—éå¸¸æ•é”ã€‚

> ä½ æ²¡çœ‹åˆ°æˆ‘ä»¬**ç›´æ¥è°ƒç”¨** `from_str()`ï¼Œä½†å®ƒå…¶å®æ˜¯åœ¨ **`.parse()` çš„èƒŒåè¢«è‡ªåŠ¨è°ƒç”¨äº†**ã€‚

---

### âœ… å…³é”®ç‚¹ï¼š`.parse()` å†…éƒ¨å°±æ˜¯è°ƒç”¨äº† `FromStr::from_str`

ä½ çœ‹åˆ°çš„è¿™å¥ï¼š

```rust
let point: Point = input.parse().unwrap();
```

ç­‰ä»·äºä¸‹é¢è¿™ç§å†™æ³•ï¼ˆæˆ‘ä»¬â€œæ‰‹åŠ¨â€è°ƒç”¨äº† `from_str()`ï¼‰ï¼š

```rust
let point: Point = Point::from_str(input).unwrap();
```

æ‰€ä»¥ï¼š

* ä½ å®ç°çš„ `from_str()` å¹¶**ä¸æ˜¯æ²¡ç”¨**
* å®ƒæ˜¯ `.parse()` è‡ªåŠ¨å¸®ä½ è°ƒç”¨çš„ï¼Œä½œç”¨æ˜¯æŠŠå­—ç¬¦ä¸² `&str` è½¬æˆä½ çš„è‡ªå®šä¹‰ç±»å‹

---

### âœ… æ›´ç›´è§‚åœ°çœ‹ä¸€ä¸‹å…³ç³»ï¼š

```rust
impl str {
    pub fn parse<T: FromStr>(&self) -> Result<T, T::Err> {
        T::from_str(self)
    }
}
```

ä¹Ÿå°±æ˜¯è¯´ï¼š

```rust
"3,4".parse::<Point>()        // å®é™…è°ƒç”¨ -> Point::from_str("3,4")
```

---

### âœ… æµ‹è¯•ï¼šæ‰‹åŠ¨è°ƒç”¨ vs parse è°ƒç”¨

ä½ å¯ä»¥äº²è‡ªè¯•è¯•ä¸‹é¢è¿™æ®µä»£ç ï¼š

```rust
fn main() {
    let input = "3,4";

    // ç”¨ parse() â€”â€” è‡ªåŠ¨è°ƒç”¨ Point::from_str
    let p1: Point = input.parse().unwrap();

    // ç›´æ¥è°ƒç”¨ from_str
    let p2 = Point::from_str(input).unwrap();

    println!("{:?}", p1);
    println!("{:?}", p2);
}
```

è¾“å‡ºä¼šä¸€æ ·ï¼Œè¯´æ˜ `.parse()` å’Œ `from_str()` æ˜¯ç­‰æ•ˆçš„è°ƒç”¨æ–¹å¼ã€‚

---

### âœ… æ€»ç»“

* `.parse()` æ˜¯ä½ è°ƒç”¨çš„â€œå‰å°â€
* `from_str()` æ˜¯ä½ å®ç°çš„â€œåå°é€»è¾‘â€
* `.parse()` ä¼šè‡ªåŠ¨å¸®ä½ è°ƒç”¨ `T::from_str()`ï¼Œåªè¦ä½ ä¸ºç±»å‹ `T` å®ç°äº† `FromStr`

---

è¦ä¸è¦æˆ‘å†ç»™ä½ ç”»ä¸ªç®€å›¾ï¼Œå±•ç¤º `parse()` å’Œ `FromStr` æ˜¯æ€ä¹ˆé…åˆçš„ï¼Ÿ
### Question
<br>
```yml
ä¸º Point å®ç° FromStrï¼Œè¿™æ ·å°±å¯ä»¥ç”¨ "3,4".parse::<Point>()ï¼Œä½ å¹¶æ²¡æœ‰åœ¨æä¾›çš„ä»£ç å®šä¹‰parse,è€Œæ˜¯ç›´æ¥ä½¿ç”¨let point: Point = input.parse().unwrap();ï¼Œè¿™æ ·çœ‹ä¸å‡ºparseä¸ä¹‹å…³è”çš„å…³ç³»
```
<br>
ä½ è¯´å¾—å¯¹â€”â€”ä»ä»£ç è¡¨é¢ä¸Šçœ‹ï¼Œ`input.parse()` å¥½åƒâ€œå‡­ç©ºè€Œæ¥â€ï¼Œè€Œæˆ‘ä»¬å¹¶**æ²¡æœ‰æ˜¾å¼å®šä¹‰ä¸€ä¸ªå« `parse` çš„å‡½æ•°**ã€‚è¿™ç¡®å®è®©äººç–‘æƒ‘å®ƒæ˜¯æ€ä¹ˆå’Œ `FromStr` è”ç³»ä¸Šçš„ã€‚

æˆ‘ä»¬æ¥**æ­å¼€è¿™ä¸ªâ€œé­”æ³•â€çš„æœ¬è´¨**ï¼š

---

## âœ… `parse()` å…¶å®æ˜¯ `&str` ç±»å‹çš„ä¸€ä¸ªé€šç”¨æ–¹æ³•

ä½ è°ƒç”¨çš„ `input.parse()`ï¼Œå…¶å®æ˜¯ Rust ä¸º `&str` ç±»å‹æä¾›çš„ä¸€ä¸ªæ–¹æ³•ï¼Œå®ƒé•¿è¿™ä¸ªæ ·å­ï¼ˆå®šä¹‰åœ¨ Rust æ ‡å‡†åº“é‡Œï¼‰ï¼š

```rust
impl str {
    pub fn parse<T: FromStr>(&self) -> Result<T, T::Err> {
        T::from_str(self)
    }
}
```

ä¹Ÿå°±æ˜¯è¯´ï¼š

* **ä½ çœ‹åˆ°çš„ `parse()` å¹¶ä¸æ˜¯ä½ å®ç°çš„ï¼Œè€Œæ˜¯æ ‡å‡†åº“é‡Œä¸º `str` ç±»å‹æä¾›çš„ï¼**
* å®ƒçš„ä½œç”¨å°±æ˜¯ï¼šè°ƒç”¨ `T::from_str(self)`ï¼Œåªè¦ä½ ç»™ `T` å®ç°äº† `FromStr`ï¼Œå®ƒå°±èƒ½ç”¨ï¼

---

## âœ… ä¸¾ä¸ªå®Œæ•´çš„å› æœé“¾ï¼ˆè°ƒç”¨è·¯å¾„ï¼‰

å½“ä½ å†™ä¸‹è¿™å¥ä»£ç ï¼š

```rust
let point: Point = input.parse().unwrap();
```

å‘ç”Ÿäº†ä»¥ä¸‹â€œå¹•ååŠ¨ä½œâ€ï¼š

1. `input` æ˜¯ `&str` ç±»å‹ï¼Œæ‰€ä»¥æœ‰ `.parse()` æ–¹æ³•ï¼ˆç”±æ ‡å‡†åº“æä¾›ï¼‰

2. ä½ æŒ‡å®šäº†ç›®æ ‡ç±»å‹æ˜¯ `Point`ï¼ŒRust çŸ¥é“ `T = Point`

3. ç¼–è¯‘å™¨æ£€æŸ¥ï¼šPoint æœ‰æ²¡æœ‰å®ç° `FromStr`

4. æœ‰ï¼æ‰€ä»¥å®ƒè°ƒç”¨ä½ å®ç°çš„ï¼š

   ```rust
   impl FromStr for Point {
       fn from_str(s: &str) -> Result<Self, Self::Err> { ... }
   }
   ```

5. `.parse()` å°±æ˜¯ `Point::from_str(input)` çš„ç®€æ´å†™æ³•

---

## âœ… å…³é”®åœ¨äº trait å’Œæ³›å‹è§£æ„

* `.parse()` çš„è¡Œä¸ºä¾èµ–äºä½ ä¼ çš„ç›®æ ‡ç±»å‹ï¼ˆå°±æ˜¯ `::<Point>`ï¼‰
* ç¼–è¯‘å™¨åœ¨èƒŒååšçš„äº‹æƒ…æ˜¯æ ¹æ® `T: FromStr` æ¥â€œåæ¨â€è¯¥è°ƒç”¨å“ªä¸ª `from_str`

---

## âœ… æƒ³è±¡ä¸€ä¸‹å¦‚æœæ²¡è¿™ä¸ªè¯­æ³•ç³–...

ä½ å°±å¾—æ‰‹åŠ¨å†™ï¼š

```rust
use std::str::FromStr;

let point = Point::from_str("3,4").unwrap();  // æ¯”è¾ƒå•°å—¦
```

Rust æä¾› `.parse()` å°±æ˜¯ä¸ºäº†è®©è¿™ç±»å­—ç¬¦ä¸²è½¬æ¢æ›´é€šç”¨å’Œä¼˜é›…ã€‚

---

## ğŸ” æ‰€ä»¥æ€»ç»“ï¼š

| ä½ çœ‹åˆ°çš„ `.parse()`           | å®é™…å‘ç”Ÿçš„äº‹æƒ…                  |
| ------------------------- | ------------------------ |
| `"3,4".parse::<Point>()`  | `Point::from_str("3,4")` |
| `.parse()` æ˜¯ `str` ä¸Šçš„é€šç”¨æ–¹æ³• | å†…éƒ¨å¸®ä½ è°ƒç”¨ `FromStr` trait   |
| ä½ å®ç°çš„æ˜¯ `from_str()`        | `parse()` ä¼šè‡ªåŠ¨ç”¨å®ƒ          |

---

å¦‚æœä½ æ„Ÿå…´è¶£ï¼Œæˆ‘å¯ä»¥ç”»ä¸ªæµç¨‹å›¾æˆ–â€œè°ƒç”¨é“¾å›¾â€ï¼Œè®©è¿™æ®µé€»è¾‘ä¸€ç›®äº†ç„¶åœ°å¯è§†åŒ–ä¸€ä¸‹ï¼Œè¦å—ï¼Ÿ

```rust
"3,4".parse::<Point>()
    â”‚
    â–¼
è°ƒç”¨ str ç±»å‹çš„ parse() æ–¹æ³•
    â”‚
    â–¼
pub fn parse<T: FromStr>(&self) -> Result<T, T::Err> {
    T::from_str(self)
}
    â”‚
    â–¼
T = Pointï¼Œå› æ­¤è°ƒç”¨ï¼š
Point::from_str("3,4")
    â”‚
    â–¼
ä½ è‡ªå·±å®ç°çš„:
impl FromStr for Point {
    fn from_str(s: &str) -> Result<Point, _> {
        // å­—ç¬¦ä¸²è§£æé€»è¾‘
    }
}
    â”‚
    â–¼
è¿”å› Ok(Point { x: 3, y: 4 }) æˆ– Err(...)
```

<br>
### Proplem:
```yml
fn from\_str(s: \&str) -> Result\<Point, \_> {,æ—¢ç„¶æ˜¯ç”¨åˆ°æˆ‘å®šä¹‰çš„ï¼Œé‚£ä¸ºä»€ä¹ˆè¿˜éœ€è¦parse
```
<br>
---
è¿™ä¸ªé—®é¢˜é—®å¾—éå¸¸å¥½ï¼Œç›´å‡» Rust trait è®¾è®¡çš„æ ¸å¿ƒæ€æƒ³ã€‚æˆ‘ä»¬æ¥åˆ†è§£è¿™ä¸ªé—®é¢˜ï¼š

---

## âœ… ä½ çš„é—®é¢˜æœ¬è´¨æ˜¯ï¼š

> æ—¢ç„¶æˆ‘å·²ç»è‡ªå·±å®ç°äº† `from_str()`ï¼Œä¸ºä»€ä¹ˆä¸ç›´æ¥è°ƒç”¨å®ƒï¼Ÿå¹²å˜›è¿˜ç»•ä¸€åœˆç”¨ `.parse()`ï¼Ÿ

ç­”æ¡ˆæ˜¯ï¼š

### â¤ ä½ å½“ç„¶**å¯ä»¥ç›´æ¥ç”¨ `from_str()`**ï¼Œ**ä½† `.parse()` æ˜¯ä¸ºäº†ç»Ÿä¸€å’Œæ³›å‹ç¼–ç¨‹è€Œè®¾è®¡çš„â€œé€šç”¨å…¥å£â€**ã€‚

---

## ğŸ” `.parse()` å­˜åœ¨çš„ä¸‰ä¸ªä¸»è¦æ„ä¹‰ï¼š

### 1. âœ… è¯­æ³•æ›´ç»Ÿä¸€ã€æ›´ç®€æ´ï¼ˆ**è¯­æ³•ç³–**ï¼‰

```rust
let p: Point = "3,4".parse().unwrap();        // ç®€æ´
let p = Point::from_str("3,4").unwrap();      // æ›´é•¿
```

`.parse()` æ˜¯ `&str` è‡ªå¸¦çš„æ–¹æ³•ï¼Œç»“åˆç±»å‹æ¨æ–­ï¼Œçœ‹èµ·æ¥æ›´è‡ªç„¶ã€æ›´çŸ­ã€æ›´ Rustã€‚

---

### 2. âœ… åœ¨æ³›å‹ä»£ç ä¸­å¹¿æ³›ä½¿ç”¨

å¦‚æœä½ å†™ä¸€ä¸ªå‡½æ•°ï¼Œå¤„ç†â€œèƒ½ä»å­—ç¬¦ä¸²è§£æå‡ºæ¥çš„ä»»æ„ç±»å‹â€ï¼Œä½ å°±å¯ä»¥ç”¨ï¼š

```rust
fn parse_any<T: FromStr>(s: &str) -> T {
    s.parse().unwrap()
}
```

ç›¸æ¯”ä¹‹ä¸‹ï¼Œå¦‚æœæ²¡æœ‰ `.parse()`ï¼Œä½ å°±è¦å†™ï¼š

```rust
fn parse_any<T: FromStr>(s: &str) -> T {
    T::from_str(s).unwrap()
}
```

è™½ç„¶ä¹Ÿå¯ä»¥ï¼Œä½† `.parse()` è®©è°ƒç”¨è€…å†™å¾—æ›´æ¸…çˆ½ï¼š

```rust
let n: i32 = parse_any("42");     // ç®€æ´
```

---

### 3. âœ… ç»Ÿä¸€ä½“éªŒï¼ˆtrait-based è®¾è®¡ç†å¿µï¼‰

Rust çš„é£æ ¼æ˜¯ï¼š**ç»Ÿä¸€è¡Œä¸ºé€šè¿‡ trait çº¦å®šï¼Œç„¶åæš´éœ²ç»Ÿä¸€æ–¹æ³•æ¥å£**ã€‚

* `FromStr` æ˜¯â€œæˆ‘å¯ä»¥ä»å­—ç¬¦ä¸²è§£æâ€çš„èƒ½åŠ›
* `.parse()` æ˜¯â€œæˆ‘è°ƒç”¨è¿™ä¸ªèƒ½åŠ›â€çš„ç»Ÿä¸€æ–¹å¼

ä½ å†™çš„ç±»å‹åªéœ€è¦å®ç° `FromStr`ï¼Œå°±è‡ªåŠ¨â€œè§£é”â€ `.parse()` æ”¯æŒ â€”â€” è¿™å°±æ˜¯ trait çš„é­”åŠ›ã€‚

---

## ğŸ” ç±»æ¯”

ä½ å°±æŠŠ `.parse()` çœ‹æˆæ˜¯ï¼š

> â€œä»å­—ç¬¦ä¸²ç”ŸæˆæŸä¸ªç±»å‹ T çš„**ç»Ÿä¸€æ¥å£**â€ï¼Œå®ƒä¸åœ¨ä¹ä½ å…·ä½“æ˜¯å“ªç§ç±»å‹ï¼Œåªè¦ä½ å®ç°äº† `FromStr`ï¼Œå®ƒå°±èƒ½ç”¨ã€‚

---

## âœ… æ€»ç»“å›ç­”ä½ çš„é—®é¢˜

> ä¸ºä»€ä¹ˆè¿˜è¦ç”¨ `.parse()`ï¼Œè€Œä¸æ˜¯ç›´æ¥è°ƒç”¨ `from_str()`ï¼Ÿ

ç­”ï¼š\*\*ä¸æ˜¯å¿…é¡»ç”¨ `.parse()`ï¼Œä½†å®ƒå¸¦æ¥ç»Ÿä¸€ã€ä¼˜é›…ã€æ³›å‹å‹å¥½çš„è°ƒç”¨æ–¹å¼ã€‚\*\*ä½ å®ç° `from_str()` æ˜¯å¿…é¡»çš„ï¼ˆè¿™æ˜¯é€»è¾‘æ ¸å¿ƒï¼‰ï¼Œ`.parse()` åªæ˜¯è°ƒç”¨è¿™ä¸ªé€»è¾‘çš„å¤–å£³ã€‚

---

ä½ è¦ä¸è¦çœ‹çœ‹ `.parse()` åœ¨å®é™…åº“æˆ–å‘½ä»¤è¡Œè§£æé‡Œæ€ä¹ˆè·Ÿæ³›å‹ç»“åˆä½¿ç”¨ï¼Ÿèƒ½ä½“ç°å®ƒçš„çœŸæ­£ä»·å€¼ã€‚
<br>
å¤ªå¥½äº†ï¼æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªç°å®ä¸­å¸¸è§çš„ä½¿ç”¨ `.parse()` çš„æ³›å‹ä¾‹å­ï¼Œæ¯”å¦‚**è§£æå‘½ä»¤è¡Œå‚æ•°**æˆ–**é€šç”¨é…ç½®å­—ç¬¦ä¸²è½¬ç±»å‹**çš„åœºæ™¯ã€‚

---

## ğŸ¯ åœºæ™¯ç¤ºä¾‹ï¼šè§£æå‘½ä»¤è¡Œå‚æ•°ï¼ˆå¦‚ clap æˆ– std::envï¼‰

ä½ å¯èƒ½ç»å¸¸å†™è¿™æ ·çš„ä»£ç ï¼š

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    // å‡è®¾ç”¨æˆ·è¾“å…¥çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯æ•°å­—
    let num: i32 = args[1].parse().expect("è¯·è¾“å…¥ä¸€ä¸ªæ•°å­—");

    println!("ä½ è¾“å…¥çš„æ•°å­—æ˜¯ï¼š{}", num);
}
```

### âœ… è¿™é‡Œçš„é‡ç‚¹ï¼š

* `args[1]` æ˜¯ä¸ª `String`
* `.parse::<i32>()` è‡ªåŠ¨å°†å…¶è½¬æ¢ä¸º `i32`
* **ç¼–è¯‘å™¨è‡ªåŠ¨æ¨æ–­å‡º `T = i32`ï¼Œè°ƒç”¨ `i32::from_str(...)`**

ä½ æ¢ä¸ªç±»å‹ï¼Œå®Œå…¨ä¸€æ ·ç”¨æ³•ï¼š

```rust
let rate: f64 = args[2].parse().unwrap();
let flag: bool = args[3].parse().unwrap();
```

ä½ å®Œå…¨**ä¸éœ€è¦å…³å¿ƒå…·ä½“æ˜¯å“ªä¸ªç±»å‹ï¼Œåªè¦ç›®æ ‡ç±»å‹å®ç°äº† `FromStr`ï¼Œéƒ½èƒ½ç»Ÿä¸€ä½¿ç”¨ `.parse()`**ã€‚

---

## âœ… æ›´é€šç”¨çš„å‡½æ•°å†™æ³•ï¼ˆçœŸæ­£ä½“ç° `.parse()` çš„æ³›å‹ä¼˜åŠ¿ï¼‰

æˆ‘ä»¬æ¥å†™ä¸€ä¸ªé€šç”¨è§£æå‡½æ•°ï¼š

```rust
use std::str::FromStr;

fn parse_arg<T: FromStr>(s: &str) -> T
where
    T::Err: std::fmt::Debug,
{
    s.parse().expect("è§£æå¤±è´¥")
}
```

ç”¨æ³•ï¼š

```rust
let n: i32 = parse_arg("42");
let pi: f64 = parse_arg("3.1415");
let yes: bool = parse_arg("true");
```

å¦‚æœæ²¡æœ‰ `.parse()`ï¼Œä½ å°±å¾—å†™ï¼š

```rust
fn parse_arg<T: FromStr>(s: &str) -> T
where
    T::Err: std::fmt::Debug,
{
    T::from_str(s).expect("è§£æå¤±è´¥")
}
```

è™½ç„¶æ²¡é”™ï¼Œä½† `.parse()` æ˜¾å¾—æ›´â€œè‡ªç„¶â€ï¼Œä¹Ÿå‡å°‘äº†ç±»å‹åç§°é‡å¤ã€‚

---

## âœ… åº”ç”¨æ€»ç»“

| åº”ç”¨åœºæ™¯          | `.parse()` çš„å¥½å¤„                          |
| ------------- | --------------------------------------- |
| å‘½ä»¤è¡Œå‚æ•°è§£æ       | æ”¯æŒä»»æ„ç±»å‹ç»Ÿä¸€è§£æ                              |
| ç¯å¢ƒå˜é‡è¯»å–        | `std::env::var("PORT")?.parse::<u16>()` |
| æ³›å‹å‡½æ•° / åº“è®¾è®¡    | æä¾›é€šç”¨è§£ææ¥å£ï¼Œç»Ÿä¸€ç”¨æˆ·è°ƒç”¨æ–¹å¼                       |
| é…ç½®è§£æï¼ˆå¦‚ .tomlï¼‰ | `.parse::<MyConfig>()?`                 |

---

è¦ä¸è¦æˆ‘å†æ¼”ç¤ºä¸€ä¸‹ï¼Œåœ¨ clap CLI å·¥å…·é‡Œç»“åˆ `.parse()` å’Œ `FromStr` è§£æç”¨æˆ·è‡ªå®šä¹‰ç»“æ„ä½“çš„ä¾‹å­ï¼Ÿè¿™åœ¨å®æˆ˜ä¸­å¾ˆæœ‰ç”¨ã€‚
<br>
### issue
```yml
let rate: f64 = args\[2].parse().unwrap();ï¼Œåƒå¹³å¸¸è¿™æ ·ä½¿ç”¨parse,æˆ‘å¹¶æ²¡æœ‰é¢å¤–å®šä¹‰FromSträ¹Ÿèƒ½ç”¨ï¼Œä¸ºä»€ä¹ˆä½ è¯´åªè¦å®ç°FromStrå°±èƒ½ä½¿ç”¨è¿™ä¸ªæ¥å£
```

è¿™ä¸ªé—®é¢˜é—®å¾—éå¸¸å…³é”®ï¼ä½ å‘ç°äº† Rust ä½¿ç”¨ `.parse()` çš„â€œçŸ›ç›¾ç‚¹â€ä¹‹ä¸€â€”â€”

---

## â“ç°è±¡

ä½ å¹³å¸¸è¿™æ ·å†™ï¼š

```rust
let n: i32 = "42".parse().unwrap();
let pi: f64 = "3.14".parse().unwrap();
let b: bool = "true".parse().unwrap();
```

ä½ **å¹¶æ²¡æœ‰æ‰‹åŠ¨ä¸º `i32`ã€`f64`ã€`bool` å®ç° `FromStr`**ï¼Œä½†å®ƒä»¬ `.parse()` å´èƒ½ç”¨ã€‚é‚£æ˜¯ä¸æ˜¯ `FromStr` å¹¶ä¸å¿…è¦ï¼Ÿ

---

## âœ… çœŸç›¸æ˜¯ï¼šä½ æ²¡æœ‰å®ç° `FromStr`ï¼Œ**ä½†æ ‡å‡†åº“å·²ç»å¸®ä½ å®ç°äº†**

Rust çš„åŸç”Ÿç±»å‹ï¼ˆå¦‚ `i32`ã€`f64`ã€`bool`ã€`String`ã€`IpAddr` ç­‰ï¼‰åœ¨æ ‡å‡†åº“ä¸­éƒ½å·²ç»å®ç°äº† `FromStr`ï¼š

```rust
impl FromStr for i32 { ... }
impl FromStr for f64 { ... }
impl FromStr for bool { ... }
```

æ‰€ä»¥ä½ æ‰èƒ½ç›´æ¥å†™ï¼š

```rust
let n: i32 = "42".parse().unwrap();
```

**è¿™ä¸æ˜¯â€œä¾‹å¤–â€ï¼Œè€Œæ˜¯å› ä¸º `i32` ç­‰ç±»å‹æ—©å°±å†…ç½®äº† `FromStr` å®ç°ï¼**

---

## ğŸ”§ æ¢å¥è¯è¯´ï¼š

> `.parse()` æœ¬è´¨ä¸Šä»ç„¶ä¾èµ– `FromStr`ï¼Œåªæ˜¯ä½ ç”¨çš„ç±»å‹ Rust å·²ç»â€œè‡ªåŠ¨å®‰æ’â€å¥½äº†ã€‚

å¦‚æœä½ å†™è‡ªå·±çš„ç±»å‹ï¼ˆæ¯”å¦‚ `struct Point`ï¼‰ï¼Œé‚£å°±å¿…é¡»ä½ æ‰‹åŠ¨å®ç° `FromStr`ï¼Œå¦åˆ™ `.parse::<Point>()` ç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼š

```rust
error[E0277]: the trait bound `Point: FromStr` is not satisfied
```

---

## âœ… ä¸¾ä¸ªå¯¹æ¯”ï¼š

| ç±»å‹         | `.parse()` èƒ½ç”¨å—ï¼Ÿ | ä¸ºå•¥èƒ½ç”¨ï¼Ÿ            |
| ---------- | --------------- | ---------------- |
| `i32`      | âœ…               | æ ‡å‡†åº“å®ç°äº† `FromStr` |
| `bool`     | âœ…               | æ ‡å‡†åº“å®ç°äº† `FromStr` |
| `Point`    | âŒï¼ˆä½ ä¸å®ç°å°±ä¸èƒ½ç”¨ï¼‰     | ä½ è¦è‡ªå·±å®ç° `FromStr` |
| `MyStruct` | âŒ               | åŒä¸Š               |

---

## âœ… æ€»ç»“ä¸€ä¸‹ä½ çš„é—®é¢˜ï¼š

> â€œä¸ºä»€ä¹ˆæˆ‘æ²¡å®ç° `FromStr` å´èƒ½ç”¨ `.parse()`ï¼Ÿâ€

* ç­”ï¼šå› ä¸ºä½ ç”¨çš„ç±»å‹ï¼ˆå¦‚ `i32`, `f64`, `bool`ï¼‰Rust æ ‡å‡†åº“å·²ç»å¸®ä½ å®ç°äº† `FromStr`
* `.parse()` æœ¬è´¨ä¸Šä»ç„¶åŸºäº `FromStr`ï¼Œåªä¸è¿‡ä½ ç”¨çš„è¿™äº›å¸¸ç”¨ç±»å‹éƒ½â€œå¼€ç®±å³ç”¨â€äº†

---

å¦‚æœä½ æƒ³çœ‹çœ‹æŸä¸ªç±»å‹æœ‰æ²¡æœ‰å®ç° `FromStr`ï¼Œå¯ä»¥æŸ¥æ–‡æ¡£ï¼ˆå¦‚ [i32 FromStr å®ç°](https://doc.rust-lang.org/std/primitive.i32.html#impl-FromStr)ï¼‰ã€‚

è¦ä¸è¦æˆ‘å†æ•™ä½ å¦‚ä½•å¿«é€Ÿç”¨ `derive` å®æ–¹å¼è®©è‡ªå·±çš„ç»“æ„ä½“è‡ªåŠ¨å®ç° `FromStr`ï¼Ÿ
<br>
### Problem
```yml
æˆ‘æƒ³çœ‹çœ‹i32å®ç°FromStrçš„ä»£ç æ˜¯ä»€ä¹ˆæ ·çš„
```
<br>
å¾ˆæ£’çš„é—®é¢˜ï¼ä¸‹é¢æˆ‘ä»¬æ¥çœ‹çœ‹ **`i32` æ˜¯å¦‚ä½•åœ¨æ ‡å‡†åº“ä¸­å®ç° `FromStr` çš„**ã€‚

---

## ğŸ“Œ å®é™…å®ç°ï¼ˆRust æ ‡å‡†åº“ä¸­çš„ `i32` çš„ `FromStr` å®ç°ï¼‰

æ ‡å‡†åº“ä¸ºæ‰€æœ‰æ•´æ•°ç±»å‹ï¼ˆå¦‚ `i32`, `u32`, `i64` ç­‰ï¼‰ç»Ÿä¸€å®ç°äº† `FromStr`ï¼Œå®ç°ä½ç½®åœ¨ï¼š

```
rust/library/core/src/num/mod.rs
```

å…¶ä¸­ `i32` çš„å®ç°å¤§è‡´å¦‚ä¸‹ï¼ˆç®€åŒ–åç‰ˆæœ¬ï¼‰ï¼š

```rust
impl FromStr for i32 {
    type Err = ParseIntError;

    fn from_str(s: &str) -> Result<i32, Self::Err> {
        // å®é™…ä¸Šæ˜¯è°ƒç”¨ i32::from_str_radix(s, 10)
        i32::from_str_radix(s, 10)
    }
}
```

---

## ğŸ§  èƒŒåé€»è¾‘è§£é‡Šï¼š

* `type Err = ParseIntError;`ï¼šè¿™æ˜¯è§£æå¤±è´¥æ—¶è¿”å›çš„é”™è¯¯ç±»å‹ï¼ˆæ ‡å‡†åº“å®šä¹‰ï¼‰
* `i32::from_str_radix(s, 10)`ï¼šè¿™æ˜¯ä¸€ä¸ªæ ¸å¿ƒå‡½æ•°ï¼Œç”¨åè¿›åˆ¶è§£æå­—ç¬¦ä¸²ï¼ˆæ¯”å¦‚ "42"ï¼‰

æ‰€ä»¥è¿™å¥ä»£ç ï¼š

```rust
let n: i32 = "42".parse().unwrap();
```

**ç­‰ä»·äºï¼š**

```rust
let n = i32::from_str("42").unwrap();
// æˆ–æ›´åº•å±‚ï¼š
let n = i32::from_str_radix("42", 10).unwrap();
```

---

## ğŸ” `ParseIntError` æ˜¯ä»€ä¹ˆï¼Ÿ

è¿™æ˜¯ Rust æ ‡å‡†åº“å®šä¹‰çš„é”™è¯¯ç±»å‹ï¼Œè¡¨ç¤ºå­—ç¬¦ä¸²ä¸èƒ½è¢«è½¬æ¢ä¸ºæ•´æ•°æ—¶çš„å„ç§å¯èƒ½é”™è¯¯ï¼Œæ¯”å¦‚ï¼š

* ç©ºå­—ç¬¦ä¸²
* åŒ…å«éæ³•å­—ç¬¦
* æ•°å­—å¤ªå¤§/å¤ªå°

ä½ å¯ä»¥ç”¨ `.parse::<i32>()` åä¸ unwrapï¼Œè€Œæ˜¯ä¼˜é›…å¤„ç†é”™è¯¯ï¼š

```rust
match "abc".parse::<i32>() {
    Ok(n) => println!("æˆåŠŸ: {}", n),
    Err(e) => println!("å¤±è´¥: {}", e),
}
```

---

## âœ… å°ç»“

| å…ƒç´                  | å†…å®¹                              |
| ------------------ | ------------------------------- |
| `i32: FromStr` å®ç°  | è°ƒç”¨ `from_str_radix(s, 10)` è¿›è¡Œè§£æ |
| é”™è¯¯ç±»å‹               | `ParseIntError`                 |
| `.parse()` èƒŒåè°ƒç”¨    | `T::from_str(&str)`             |
| æ‰€ä»¥èƒ½ç›´æ¥ä½¿ç”¨ `.parse()` | æ˜¯å› ä¸ºæ ‡å‡†åº“æå‰ä¸ºä½ åšå¥½äº† `FromStr` å®ç°      |

---

å¦‚æœä½ æ„Ÿå…´è¶£ï¼Œæˆ‘è¿˜å¯ä»¥å±•ç¤ºæ ‡å‡†åº“æ˜¯å¦‚ä½•ä¸ºæ‰€æœ‰æ•´æ•°ç±»å‹ç»Ÿä¸€ç”Ÿæˆ `FromStr` çš„ï¼ˆç”¨å®ï¼‰â€”â€”é‚£éƒ¨åˆ†ä¹ŸæŒºæœ‰è¶£ã€‚è¦çœ‹ä¸€ä¸‹å—ï¼Ÿ

### å‰é¢å®ç°FromStrçš„ä»£ç 
<br>
```rust
use std::str::FromStr;

#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

// ä¸º Point å®ç° FromStrï¼Œè¿™æ ·å°±å¯ä»¥ç”¨ "3,4".parse::<Point>()
impl FromStr for Point {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        // æ‹†åˆ†å­—ç¬¦ä¸²ï¼Œå½¢å¦‚ "3,4"
        let parts: Vec<&str> = s.split(',').collect();
        if parts.len() != 2 {
            return Err("æ ¼å¼å¿…é¡»æ˜¯ x,y".to_string());
        }

        let x = parts[0].trim().parse::<i32>().map_err(|_| "x è§£æå¤±è´¥")?;
        let y = parts[1].trim().parse::<i32>().map_err(|_| "y è§£æå¤±è´¥")?;

        Ok(Point { x, y })
    }
}

fn main() {
    let input = "3,4";
    let point: Point = input.parse().unwrap();

    println!("è§£æåçš„åæ ‡æ˜¯: {:?}", point);
}
```







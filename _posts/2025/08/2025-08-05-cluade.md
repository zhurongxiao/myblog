---
layout: post
title: "claude "
date: 2025-08-05 14:42:00 +0800
categories: gather
---
### 用户:
# 项目结构
```
src/
├── main.rs
├── config.rs
├── database/
│   ├── mod.rs
│   ├── models.rs
│   └── init.rs
├── handlers/
│   ├── mod.rs
│   ├── auth.rs
│   ├── comments.rs
│   └── health.rs
├── services/
│   ├── mod.rs
│   ├── auth_service.rs
│   ├── comment_service.rs
│   └── vote_service.rs
└── utils/
    ├── mod.rs
    └── cors.rs
```,帮我加入文章管理（基本的get, post)和其它实用的功能，一篇文章包含类别，标签标题，标题图片url,内容（md格式），创建日期，再加入**GraphQL的特性进去**
main.rs->->// ## src/main.rs
mod config;
mod database;
mod handlers;
mod services;
mod utils;

use axum::{
    routing::{get, post},
    Router,
};
use std::net::SocketAddr;
use tokio::net::TcpListener;

use config::AppConfig;
use database::init::init_database;
use handlers::{auth, comments, health};
use utils::cors::create_cors_layer;

#[tokio::main]
async fn main() {
    println!("🚀 启动应用程序...");

    // 初始化配置
    let config = AppConfig::from_env();

    // 创建数据库连接池
    let pool = config.create_db_pool().expect("无法创建数据库连接池");

    // 初始化数据库
    if let Err(e) = init_database(&pool).await {
        eprintln!("❌ 数据库初始化失败: {:?}", e);
        std::process::exit(1);
    }
    println!("✅ 数据库初始化完成");

    // 创建路由
    let app = Router::new()
        .route("/", get(health::health_check))
        .route("/api/health", get(health::health_check))
        .route("/api/google-login", post(auth::handle_google_login))
        .route("/api/google-logout", post(auth::handle_google_logout))
        .route("/api/comments", get(comments::get_comments))
        .route("/api/comments", post(comments::create_comment))
        .route("/api/comments/vote", post(comments::handle_vote))
        .with_state(pool)
        .layer(create_cors_layer());

    let addr = SocketAddr::from(([0, 0, 0, 0], config.port));

    println!("🚀 服务运行在 http://0.0.0.0:{}", config.port);
    println!("🔗 本地访问: http://localhost:{}", config.port);
    println!("💬 讨论区功能已启用");
    println!("🗳️ 投票功能已启用");
    println!("💭 回复功能已启用");
    println!("🗄️ 使用 PostgreSQL 数据库: {}", config.db_name);

    let listener = TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}
 config.rs->->// ## src/config.rs
use deadpool_postgres::{Config, Pool, Runtime};
use tokio_postgres::NoTls;

pub struct AppConfig {
    pub port: u16,
    pub db_host: String,
    pub db_port: u16,
    pub db_user: String,
    pub db_password: String,
    pub db_name: String,
}

impl AppConfig {
    pub fn from_env() -> Self {
        Self {
            port: std::env::var("PORT")
                .unwrap_or_else(|_| "3001".to_string())
                .parse()
                .expect("PORT must be a valid number"),
            db_host: std::env::var("DB_HOST").unwrap_or_else(|_| "localhost".to_string()),
            db_port: std::env::var("DB_PORT")
                .unwrap_or_else(|_| "5432".to_string())
                .parse()
                .expect("DB_PORT must be a valid number"),
            db_user: std::env::var("DB_USER").unwrap_or_else(|_| "postgres".to_string()),
            db_password: std::env::var("DB_PASSWORD").unwrap_or_else(|_| "zz123123".to_string()),
            db_name: std::env::var("DB_NAME").unwrap_or_else(|_| "user_comments".to_string()),
        }
    }

    pub fn create_db_pool(&self) -> Result<Pool, Box<dyn std::error::Error>> {
        let mut cfg = Config::new();
        cfg.host = Some(self.db_host.clone());
        cfg.port = Some(self.db_port);
        cfg.user = Some(self.db_user.clone());
        cfg.password = Some(self.db_password.clone());
        cfg.dbname = Some(self.db_name.clone());

        Ok(cfg.create_pool(Some(Runtime::Tokio1), NoTls)?)
    }
}
 init.rs->->// ## src/database/init.rs
use deadpool_postgres::Pool;

pub async fn init_database(pool: &Pool) -> Result<(), Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    // 创建用户表
    client
        .execute(
            "CREATE TABLE IF NOT EXISTS users (
            id BIGSERIAL PRIMARY KEY,
            google_id TEXT UNIQUE NOT NULL,
            email TEXT NOT NULL,
            name TEXT NOT NULL,
            picture TEXT,
            created_at TIMESTAMPTZ NOT NULL,
            last_login TIMESTAMPTZ NOT NULL
        )",
            &[],
        )
        .await?;

    // 创建评论表
    client
        .execute(
            "CREATE TABLE IF NOT EXISTS comments (
            id TEXT PRIMARY KEY,
            content TEXT NOT NULL,
            author_name TEXT NOT NULL,
            author_email TEXT NOT NULL,
            author_picture TEXT NOT NULL,
            parent_id TEXT NULL,
            created_at TIMESTAMPTZ NOT NULL,
            FOREIGN KEY (parent_id) REFERENCES comments (id) ON DELETE CASCADE
        )",
            &[],
        )
        .await?;

    // 创建投票表
    client
        .execute(
            "CREATE TABLE IF NOT EXISTS comment_votes (
            id BIGSERIAL PRIMARY KEY,
            comment_id TEXT NOT NULL,
            user_email TEXT NOT NULL,
            vote_type TEXT NOT NULL CHECK (vote_type IN ('up', 'down')),
            created_at TIMESTAMPTZ NOT NULL,
            UNIQUE(comment_id, user_email),
            FOREIGN KEY (comment_id) REFERENCES comments (id) ON DELETE CASCADE
        )",
            &[],
        )
        .await?;

    // 创建索引
    create_indexes(&client).await?;

    Ok(())
}

async fn create_indexes(client: &tokio_postgres::Client) -> Result<(), tokio_postgres::Error> {
    let indexes = [
        "CREATE INDEX IF NOT EXISTS idx_comments_created_at ON comments (created_at DESC)",
        "CREATE INDEX IF NOT EXISTS idx_comments_parent_id ON comments (parent_id)",
        "CREATE INDEX IF NOT EXISTS idx_users_google_id ON users (google_id)",
        "CREATE INDEX IF NOT EXISTS idx_users_email ON users (email)",
        "CREATE INDEX IF NOT EXISTS idx_votes_comment_user ON comment_votes (comment_id, user_email)",
    ];

    for &index_sql in &indexes {
        client.execute(index_sql, &[]).await?;
    }

    Ok(())
}
 models.rs->->// ## src/database/models.rs
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

// 前端发送的数据格式
#[derive(Deserialize)]
pub struct GoogleLoginPayload {
    pub credential: String, // ID token
}

// 解析 Google 返回的 token 信息
#[derive(Debug, Deserialize)]
pub struct GoogleUserInfo {
    pub email: String,
    pub name: String,
    #[allow(dead_code)]
    pub picture: Option<String>,
    pub sub: String, // 用户唯一标识
}

// 用户数据结构
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: i64,
    pub google_id: String,
    pub email: String,
    pub name: String,
    pub picture: Option<String>,
    pub created_at: DateTime<Utc>,
    pub last_login: DateTime<Utc>,
}

// 评论相关的数据结构
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommentAuthor {
    pub name: String,
    pub email: String,
    pub picture: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Comment {
    pub id: String,
    pub content: String,
    pub author: CommentAuthor,
    #[serde(rename = "createdAt")]
    pub created_at: DateTime<Utc>,
    pub timestamp: String,         // 用于兼容前端
    pub parent_id: Option<String>, // 父评论ID，用于回复功能
    pub upvotes: i32,              // 点赞数
    pub downvotes: i32,            // 点踩数
    pub user_vote: Option<String>, // 当前用户的投票状态 ("up", "down", null)
    pub replies: Vec<Comment>,     // 回复列表
}

#[derive(Deserialize)]
pub struct CreateCommentPayload {
    pub content: String,
    pub author: CommentAuthor,
    pub parent_id: Option<String>, // 父评论ID
}

#[derive(Deserialize)]
pub struct VotePayload {
    pub comment_id: String,
    pub vote_type: String, // "up", "down", "remove"
    pub user_email: String,
}

#[derive(Serialize)]
pub struct CommentsResponse {
    pub comments: Vec<Comment>,
}

#[derive(Serialize)]
pub struct VoteResponse {
    pub upvotes: i32,
    pub downvotes: i32,
    pub user_vote: Option<String>,
}
 mod.rs->->// ## src/database/mod.rs
pub mod init;
pub mod models;

pub use models::*;
 comments.rs->->// ## src/handlers/comments.rs
use crate::database::{Comment, CommentsResponse, CreateCommentPayload, VotePayload, VoteResponse};
use crate::handlers::DbPool;
use crate::services::{comment_service, vote_service};
use axum::{
    extract::{Query, State},
    http::StatusCode,
    Json,
};
use std::collections::HashMap;

pub async fn get_comments(
    State(pool): State<DbPool>,
    user_email: Option<Query<HashMap<String, String>>>,
) -> Result<Json<CommentsResponse>, (StatusCode, &'static str)> {
    println!("📝 获取评论列表");

    let current_user_email = user_email.and_then(|query| query.get("user_email").cloned());

    match comment_service::get_all_comments(&pool, current_user_email.as_deref()).await {
        Ok(comments) => {
            println!("✅ 返回 {} 条评论", comments.len());
            Ok(Json(CommentsResponse { comments }))
        }
        Err(e) => {
            eprintln!("❌ 获取评论失败: {:?}", e);
            Err((StatusCode::INTERNAL_SERVER_ERROR, "获取评论失败"))
        }
    }
}

pub async fn create_comment(
    State(pool): State<DbPool>,
    Json(payload): Json<CreateCommentPayload>,
) -> Result<Json<Comment>, (StatusCode, &'static str)> {
    println!("📝 收到新评论: {} 字符", payload.content.len());

    // 验证评论内容
    if let Err(msg) = comment_service::validate_comment_payload(&payload) {
        return Err((StatusCode::BAD_REQUEST, msg));
    }

    match comment_service::create_new_comment(&pool, payload).await {
        Ok(comment) => {
            let comment_type = if comment.parent_id.is_some() {
                "回复"
            } else {
                "评论"
            };
            println!(
                "✅ {}已保存到数据库: {} <{}> - {}",
                comment_type,
                comment.author.name,
                comment.author.email,
                &comment.content[..std::cmp::min(50, comment.content.len())]
            );
            Ok(Json(comment))
        }
        Err(e) => {
            eprintln!("❌ 创建评论失败: {:?}", e);
            Err((StatusCode::INTERNAL_SERVER_ERROR, "创建评论失败"))
        }
    }
}

pub async fn handle_vote(
    State(pool): State<DbPool>,
    Json(payload): Json<VotePayload>,
) -> Result<Json<VoteResponse>, (StatusCode, &'static str)> {
    println!(
        "🗳️ 收到投票请求: {} - {}",
        payload.comment_id, payload.vote_type
    );

    // 验证投票类型
    if !["up", "down", "remove"].contains(&payload.vote_type.as_str()) {
        return Err((StatusCode::BAD_REQUEST, "无效的投票类型"));
    }

    match vote_service::process_vote(&pool, payload).await {
        Ok(vote_response) => {
            println!(
                "✅ 投票已更新: (+{} -{}) 用户投票: {:?}",
                vote_response.upvotes, vote_response.downvotes, vote_response.user_vote
            );
            Ok(Json(vote_response))
        }
        Err(e) => {
            eprintln!("❌ 处理投票失败: {:?}", e);
            Err((StatusCode::INTERNAL_SERVER_ERROR, "处理投票失败"))
        }
    }
}
 mod.rs->->// ## src/handlers/mod.rs
pub mod auth;
pub mod comments;
pub mod health;

pub type DbPool = deadpool_postgres::Pool;
 auth.rs->->// ## src/handlers/auth.rs
use crate::database::{GoogleLoginPayload, User};
use crate::handlers::DbPool;
use crate::services::auth_service;
use axum::{extract::State, http::StatusCode, Json};

pub async fn handle_google_login(
    State(pool): State<DbPool>,
    Json(payload): Json<GoogleLoginPayload>,
) -> Result<Json<User>, (StatusCode, &'static str)> {
    println!("🔑 收到登录请求，验证 ID token...");

    match auth_service::authenticate_google_user(&pool, &payload.credential).await {
        Ok(user) => {
            println!("✅ 登录成功: {} <{}>", user.name, user.email);
            Ok(Json(user))
        }
        Err(e) => {
            eprintln!("❌ 登录失败: {:?}", e);
            Err((StatusCode::UNAUTHORIZED, "登录失败"))
        }
    }
}

pub async fn handle_google_logout() -> &'static str {
    println!("👋 用户已登出");
    "登出成功"
}
 health.rs->->// # src/handlers/health.rs
pub async fn health_check() -> &'static str {
    "后端服务运行正常"
}
 auth_service.rs->->// ## src/services/auth_service.rs
use crate::database::{GoogleUserInfo, User};
use chrono::Utc;
use deadpool_postgres::Pool;

pub async fn authenticate_google_user(
    pool: &Pool,
    id_token: &str,
) -> Result<User, Box<dyn std::error::Error>> {
    // 调用 Google 的 tokeninfo 接口验证 ID token
    let verify_url = format!(
        "https://oauth2.googleapis.com/tokeninfo?id_token={}",
        id_token
    );

    let response = reqwest::get(&verify_url).await?;

    if !response.status().is_success() {
        return Err("Invalid Google token".into());
    }

    let user_info: GoogleUserInfo = response.json().await?;

    // 保存或更新用户信息
    save_or_update_user(pool, &user_info).await
}

async fn save_or_update_user(
    pool: &Pool,
    user_info: &GoogleUserInfo,
) -> Result<User, Box<dyn std::error::Error>> {
    let client = pool.get().await?;
    let now = Utc::now();

    // 首先尝试更新现有用户的最后登录时间
    let rows_affected = client
        .execute(
            "UPDATE users SET last_login = $1, name = $2, picture = $3 
         WHERE google_id = $4",
            &[&now, &user_info.name, &user_info.picture, &user_info.sub],
        )
        .await?;

    if rows_affected == 0 {
        // 用户不存在，创建新用户
        client
            .execute(
                "INSERT INTO users (google_id, email, name, picture, created_at, last_login)
             VALUES ($1, $2, $3, $4, $5, $6)",
                &[
                    &user_info.sub,
                    &user_info.email,
                    &user_info.name,
                    &user_info.picture,
                    &now,
                    &now,
                ],
            )
            .await?;
    }

    // 获取用户信息返回
    let row = client
        .query_one(
            "SELECT id, google_id, email, name, picture, created_at, last_login 
         FROM users WHERE google_id = $1",
            &[&user_info.sub],
        )
        .await?;

    Ok(User {
        id: row.get(0),
        google_id: row.get(1),
        email: row.get(2),
        name: row.get(3),
        picture: row.get(4),
        created_at: row.get(5),
        last_login: row.get(6),
    })
}
 mod.rs->->// ## src/services/mod.rs
pub mod auth_service;
pub mod comment_service;
pub mod vote_service;
 vote_service.rs->->// ## src/services/vote_service.rs
use crate::database::{VotePayload, VoteResponse};
use chrono::Utc;
use deadpool_postgres::Pool;

pub async fn get_comment_votes(
    pool: &Pool,
    comment_id: &str,
    user_email: Option<&str>,
) -> Result<(i32, i32, Option<String>), Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    // 获取总投票数
    let row = client
        .query_one(
            "SELECT 
            SUM(CASE WHEN vote_type = 'up' THEN 1 ELSE 0 END) as upvotes,
            SUM(CASE WHEN vote_type = 'down' THEN 1 ELSE 0 END) as downvotes
         FROM comment_votes WHERE comment_id = $1",
            &[&comment_id],
        )
        .await?;

    let upvotes: i64 = row.get::<_, Option<i64>>(0).unwrap_or(0);
    let downvotes: i64 = row.get::<_, Option<i64>>(1).unwrap_or(0);

    // 获取当前用户的投票状态
    let user_vote = if let Some(email) = user_email {
        match client
            .query_opt(
                "SELECT vote_type FROM comment_votes WHERE comment_id = $1 AND user_email = $2",
                &[&comment_id, &email],
            )
            .await?
        {
            Some(row) => Some(row.get::<_, String>(0)),
            None => None,
        }
    } else {
        None
    };

    Ok((upvotes as i32, downvotes as i32, user_vote))
}

pub async fn process_vote(
    pool: &Pool,
    payload: VotePayload,
) -> Result<VoteResponse, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    // 验证评论是否存在
    let row = client
        .query_opt(
            "SELECT COUNT(*) FROM comments WHERE id = $1",
            &[&payload.comment_id],
        )
        .await?;
    if let Some(row) = row {
        let count: i64 = row.get(0);
        if count == 0 {
            return Err("评论不存在".into());
        }
    }

    let now = Utc::now();

    // 处理投票
    if payload.vote_type == "remove" {
        // 移除投票
        client
            .execute(
                "DELETE FROM comment_votes WHERE comment_id = $1 AND user_email = $2",
                &[&payload.comment_id, &payload.user_email],
            )
            .await?;
    } else {
        // 插入或更新投票
        client
            .execute(
                "INSERT INTO comment_votes (comment_id, user_email, vote_type, created_at)
             VALUES ($1, $2, $3, $4)
             ON CONFLICT (comment_id, user_email) 
             DO UPDATE SET vote_type = EXCLUDED.vote_type, created_at = EXCLUDED.created_at",
                &[
                    &payload.comment_id,
                    &payload.user_email,
                    &payload.vote_type,
                    &now,
                ],
            )
            .await?;
    }

    // 获取更新后的投票信息
    let (upvotes, downvotes, user_vote) =
        get_comment_votes(pool, &payload.comment_id, Some(&payload.user_email)).await?;

    Ok(VoteResponse {
        upvotes,
        downvotes,
        user_vote,
    })
}
 comment_service.rs->->// ## src/services/comment_service.rs
use crate::database::{Comment, CommentAuthor, CreateCommentPayload};
use crate::services::vote_service;
use chrono::Utc;
use deadpool_postgres::Pool;
use uuid::Uuid;

pub fn validate_comment_payload(payload: &CreateCommentPayload) -> Result<(), &'static str> {
    let content = payload.content.trim();
    if content.is_empty() {
        return Err("评论内容不能为空");
    }
    if content.len() > 500 {
        return Err("评论内容不能超过500字符");
    }
    if payload.author.name.trim().is_empty() || payload.author.email.trim().is_empty() {
        return Err("用户信息不完整");
    }
    Ok(())
}

pub async fn get_all_comments(
    pool: &Pool,
    user_email: Option<&str>,
) -> Result<Vec<Comment>, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    let rows = client
        .query(
            "SELECT id, content, author_name, author_email, author_picture, created_at, parent_id 
         FROM comments ORDER BY created_at ASC",
            &[],
        )
        .await?;

    let mut comments = Vec::new();

    for row in rows {
        let created_at = row.get(5);
        let mut comment = Comment {
            id: row.get(0),
            content: row.get(1),
            author: CommentAuthor {
                name: row.get(2),
                email: row.get(3),
                picture: row.get(4),
            },
            created_at,
            timestamp: created_at.to_rfc3339(),
            parent_id: row.get(6),
            upvotes: 0,
            downvotes: 0,
            user_vote: None,
            replies: Vec::new(),
        };

        // 获取投票信息
        if let Ok((upvotes, downvotes, user_vote)) =
            vote_service::get_comment_votes(pool, &comment.id, user_email).await
        {
            comment.upvotes = upvotes;
            comment.downvotes = downvotes;
            comment.user_vote = user_vote;
        }

        comments.push(comment);
    }

    Ok(comments)
}

pub async fn create_new_comment(
    pool: &Pool,
    payload: CreateCommentPayload,
) -> Result<Comment, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    // 如果是回复，验证父评论是否存在
    if let Some(parent_id) = &payload.parent_id {
        let row = client
            .query_opt("SELECT COUNT(*) FROM comments WHERE id = $1", &[parent_id])
            .await?;
        if let Some(row) = row {
            let count: i64 = row.get(0);
            if count == 0 {
                return Err("父评论不存在".into());
            }
        }
    }

    let now = Utc::now();
    let comment_id = Uuid::new_v4().to_string();
    let content = payload.content.trim();

    // 保存评论到数据库
    client.execute(
        "INSERT INTO comments (id, content, author_name, author_email, author_picture, created_at, parent_id)
         VALUES ($1, $2, $3, $4, $5, $6, $7)",
        &[
            &comment_id,
            &content,
            &payload.author.name,
            &payload.author.email,
            &payload.author.picture,
            &now,
            &payload.parent_id,
        ],
    ).await?;

    Ok(Comment {
        id: comment_id,
        content: content.to_string(),
        author: payload.author,
        created_at: now,
        timestamp: now.to_rfc3339(),
        parent_id: payload.parent_id,
        upvotes: 0,
        downvotes: 0,
        user_vote: None,
        replies: Vec::new(),
    })
}
 cors.rs->->// ## src/utils/cors.rs
use axum::http::{header, HeaderValue, Method};
use tower_http::cors::CorsLayer;

pub fn create_cors_layer() -> CorsLayer {
    CorsLayer::new()
        .allow_origin([
            HeaderValue::from_static("http://localhost:5173"),
            HeaderValue::from_static("http://localhost:5174"),
            HeaderValue::from_static("http://127.0.0.1:5173"),
            HeaderValue::from_static("http://127.0.0.1:5174"),
            HeaderValue::from_static("https://btc.apin.app"),
            HeaderValue::from_static("https://www.btc.apin.app"),
            HeaderValue::from_static("https://www.apin.app"),
            HeaderValue::from_static("https://apin.app"),
            HeaderValue::from_static("https://fly.apin.app"),
            HeaderValue::from_static("https://test.apin.app"),
            HeaderValue::from_static("https://web-btc.fly.dev"),
        ])
        .allow_methods([Method::GET, Method::POST, Method::OPTIONS])
        .allow_headers([header::CONTENT_TYPE, header::AUTHORIZATION])
}
 mod.rs->->// ## src/utils/mod.rs
pub mod cors;

### 系统:
我来帮你为这个项目添加文章管理功能和 GraphQL 特性。首先，我需要更新依赖项，然后添加相应的模块。 代码
```toml
[package]
name = "blog-api"
version = "0.1.0"
edition = "2021"

[dependencies]
# Web 框架
axum = { version = "0.7", features = ["macros"] }
tokio = { version = "1.0", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors"] }

# 数据库
deadpool-postgres = "0.14"
tokio-postgres = { version = "0.7", features = ["with-chrono-0_4", "with-uuid-1"] }

# GraphQL
async-graphql = { version = "7.0", features = ["chrono", "uuid"] }
async-graphql-axum = "7.0"

# 序列化
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# 日期时间
chrono = { version = "0.4", features = ["serde"] }

# UUID
uuid = { version = "1.0", features = ["v4", "serde"] }

# HTTP 客户端
reqwest = { version = "0.12", features = ["json"] }

# 环境变量
dotenv = "0.15"

# 错误处理
anyhow = "1.0"
thiserror = "1.0"
```
 代码
```rust
// ## src/database/init.rs
use deadpool_postgres::Pool;

pub async fn init_database(pool: &Pool) -> Result<(), Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    // 创建用户表
    client
        .execute(
            "CREATE TABLE IF NOT EXISTS users (
            id BIGSERIAL PRIMARY KEY,
            google_id TEXT UNIQUE NOT NULL,
            email TEXT NOT NULL,
            name TEXT NOT NULL,
            picture TEXT,
            created_at TIMESTAMPTZ NOT NULL,
            last_login TIMESTAMPTZ NOT NULL
        )",
            &[],
        )
        .await?;

    // 创建分类表
    client
        .execute(
            "CREATE TABLE IF NOT EXISTS categories (
            id BIGSERIAL PRIMARY KEY,
            name TEXT UNIQUE NOT NULL,
            description TEXT,
            slug TEXT UNIQUE NOT NULL,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        )",
            &[],
        )
        .await?;

    // 创建标签表
    client
        .execute(
            "CREATE TABLE IF NOT EXISTS tags (
            id BIGSERIAL PRIMARY KEY,
            name TEXT UNIQUE NOT NULL,
            slug TEXT UNIQUE NOT NULL,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        )",
            &[],
        )
        .await?;

    // 创建文章表
    client
        .execute(
            "CREATE TABLE IF NOT EXISTS articles (
            id TEXT PRIMARY KEY,
            title TEXT NOT NULL,
            slug TEXT UNIQUE NOT NULL,
            content TEXT NOT NULL,
            excerpt TEXT,
            image_url TEXT,
            category_id BIGINT REFERENCES categories(id),
            author_id BIGINT NOT NULL REFERENCES users(id),
            status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'archived')),
            view_count BIGINT NOT NULL DEFAULT 0,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            published_at TIMESTAMPTZ
        )",
            &[],
        )
        .await?;

    // 创建文章标签关联表
    client
        .execute(
            "CREATE TABLE IF NOT EXISTS article_tags (
            article_id TEXT NOT NULL REFERENCES articles(id) ON DELETE CASCADE,
            tag_id BIGINT NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
            PRIMARY KEY (article_id, tag_id)
        )",
            &[],
        )
        .await?;

    // 创建评论表
    client
        .execute(
            "CREATE TABLE IF NOT EXISTS comments (
            id TEXT PRIMARY KEY,
            content TEXT NOT NULL,
            author_name TEXT NOT NULL,
            author_email TEXT NOT NULL,
            author_picture TEXT NOT NULL,
            parent_id TEXT NULL,
            article_id TEXT NULL REFERENCES articles(id) ON DELETE CASCADE,
            created_at TIMESTAMPTZ NOT NULL,
            FOREIGN KEY (parent_id) REFERENCES comments (id) ON DELETE CASCADE
        )",
            &[],
        )
        .await?;

    // 创建投票表
    client
        .execute(
            "CREATE TABLE IF NOT EXISTS comment_votes (
            id BIGSERIAL PRIMARY KEY,
            comment_id TEXT NOT NULL,
            user_email TEXT NOT NULL,
            vote_type TEXT NOT NULL CHECK (vote_type IN ('up', 'down')),
            created_at TIMESTAMPTZ NOT NULL,
            UNIQUE(comment_id, user_email),
            FOREIGN KEY (comment_id) REFERENCES comments (id) ON DELETE CASCADE
        )",
            &[],
        )
        .await?;

    // 创建索引
    create_indexes(&client).await?;

    // 插入默认数据
    insert_default_data(&client).await?;

    Ok(())
}

async fn create_indexes(client: &tokio_postgres::Client) -> Result<(), tokio_postgres::Error> {
    let indexes = [
        // 原有索引
        "CREATE INDEX IF NOT EXISTS idx_comments_created_at ON comments (created_at DESC)",
        "CREATE INDEX IF NOT EXISTS idx_comments_parent_id ON comments (parent_id)",
        "CREATE INDEX IF NOT EXISTS idx_users_google_id ON users (google_id)",
        "CREATE INDEX IF NOT EXISTS idx_users_email ON users (email)",
        "CREATE INDEX IF NOT EXISTS idx_votes_comment_user ON comment_votes (comment_id, user_email)",
        
        // 文章相关索引
        "CREATE INDEX IF NOT EXISTS idx_articles_status ON articles (status)",
        "CREATE INDEX IF NOT EXISTS idx_articles_category ON articles (category_id)",
        "CREATE INDEX IF NOT EXISTS idx_articles_author ON articles (author_id)",
        "CREATE INDEX IF NOT EXISTS idx_articles_created_at ON articles (created_at DESC)",
        "CREATE INDEX IF NOT EXISTS idx_articles_published_at ON articles (published_at DESC)",
        "CREATE INDEX IF NOT EXISTS idx_articles_slug ON articles (slug)",
        "CREATE INDEX IF NOT EXISTS idx_categories_slug ON categories (slug)",
        "CREATE INDEX IF NOT EXISTS idx_tags_slug ON tags (slug)",
        "CREATE INDEX IF NOT EXISTS idx_comments_article ON comments (article_id)",
    ];

    for &index_sql in &indexes {
        client.execute(index_sql, &[]).await?;
    }

    Ok(())
}

async fn insert_default_data(client: &tokio_postgres::Client) -> Result<(), tokio_postgres::Error> {
    // 插入默认分类
    let default_categories = [
        ("技术", "Technology", "technology", "技术相关的文章"),
        ("生活", "Life", "life", "生活感悟和日常分享"),
        ("随笔", "Essays", "essays", "随笔杂谈"),
    ];

    for (name, _en_name, slug, description) in &default_categories {
        client
            .execute(
                "INSERT INTO categories (name, slug, description) 
                 VALUES ($1, $2, $3) 
                 ON CONFLICT (slug) DO NOTHING",
                &[name, slug, description],
            )
            .await?;
    }

    // 插入默认标签
    let default_tags = [
        ("Rust", "rust"),
        ("JavaScript", "javascript"),
        ("Python", "python"),
        ("Web开发", "web-development"),
        ("数据库", "database"),
        ("前端", "frontend"),
        ("后端", "backend"),
        ("教程", "tutorial"),
        ("经验分享", "experience"),
    ];

    for (name, slug) in &default_tags {
        client
            .execute(
                "INSERT INTO tags (name, slug) 
                 VALUES ($1, $2) 
                 ON CONFLICT (slug) DO NOTHING",
                &[name, slug],
            )
            .await?;
    }

    Ok(())
}
```
 代码
```rust
// ## src/database/models.rs
use async_graphql::*;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

// 前端发送的数据格式
#[derive(Deserialize)]
pub struct GoogleLoginPayload {
    pub credential: String, // ID token
}

// 解析 Google 返回的 token 信息
#[derive(Debug, Deserialize)]
pub struct GoogleUserInfo {
    pub email: String,
    pub name: String,
    #[allow(dead_code)]
    pub picture: Option<String>,
    pub sub: String, // 用户唯一标识
}

// 用户数据结构
#[derive(Debug, Clone, Serialize, Deserialize, SimpleObject)]
#[graphql(complex)]
pub struct User {
    pub id: i64,
    pub google_id: String,
    pub email: String,
    pub name: String,
    pub picture: Option<String>,
    pub created_at: DateTime<Utc>,
    pub last_login: DateTime<Utc>,
}

#[ComplexObject]
impl User {
    async fn articles(&self, ctx: &Context<'_>) -> FieldResult<Vec<Article>> {
        // 这里可以实现获取用户文章的逻辑
        // 暂时返回空数组
        Ok(vec![])
    }
}

// 分类数据结构
#[derive(Debug, Clone, Serialize, Deserialize, SimpleObject)]
#[graphql(complex)]
pub struct Category {
    pub id: i64,
    pub name: String,
    pub slug: String,
    pub description: Option<String>,
    pub created_at: DateTime<Utc>,
}

#[ComplexObject]
impl Category {
    async fn articles(&self, ctx: &Context<'_>) -> FieldResult<Vec<Article>> {
        // 实现获取分类下的文章
        Ok(vec![])
    }

    async fn article_count(&self, ctx: &Context<'_>) -> FieldResult<i32> {
        // 实现获取分类下的文章数量
        Ok(0)
    }
}

// 标签数据结构
#[derive(Debug, Clone, Serialize, Deserialize, SimpleObject)]
#[graphql(complex)]
pub struct Tag {
    pub id: i64,
    pub name: String,
    pub slug: String,
    pub created_at: DateTime<Utc>,
}

#[ComplexObject]
impl Tag {
    async fn articles(&self, ctx: &Context<'_>) -> FieldResult<Vec<Article>> {
        // 实现获取标签下的文章
        Ok(vec![])
    }

    async fn article_count(&self, ctx: &Context<'_>) -> FieldResult<i32> {
        // 实现获取标签下的文章数量
        Ok(0)
    }
}

// 文章状态枚举
#[derive(Debug, Clone, Serialize, Deserialize, Enum, Copy, PartialEq, Eq)]
pub enum ArticleStatus {
    Draft,
    Published,
    Archived,
}

impl From<String> for ArticleStatus {
    fn from(s: String) -> Self {
        match s.as_str() {
            "published" => ArticleStatus::Published,
            "archived" => ArticleStatus::Archived,
            _ => ArticleStatus::Draft,
        }
    }
}

impl From<ArticleStatus> for String {
    fn from(status: ArticleStatus) -> Self {
        match status {
            ArticleStatus::Draft => "draft".to_string(),
            ArticleStatus::Published => "published".to_string(),
            ArticleStatus::Archived => "archived".to_string(),
        }
    }
}

// 文章数据结构
#[derive(Debug, Clone, Serialize, Deserialize, SimpleObject)]
#[graphql(complex)]
pub struct Article {
    pub id: String,
    pub title: String,
    pub slug: String,
    pub content: String,
    pub excerpt: Option<String>,
    pub image_url: Option<String>,
    pub status: ArticleStatus,
    pub view_count: i64,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub published_at: Option<DateTime<Utc>>,
}

#[ComplexObject]
impl Article {
    async fn author(&self, ctx: &Context<'_>) -> FieldResult<Option<User>> {
        // 实现获取文章作者
        Ok(None)
    }

    async fn category(&self, ctx: &Context<'_>) -> FieldResult<Option<Category>> {
        // 实现获取文章分类
        Ok(None)
    }

    async fn tags(&self, ctx: &Context<'_>) -> FieldResult<Vec<Tag>> {
        // 实现获取文章标签
        Ok(vec![])
    }

    async fn comments(&self, ctx: &Context<'_>) -> FieldResult<Vec<Comment>> {
        // 实现获取文章评论
        Ok(vec![])
    }

    async fn comment_count(&self, ctx: &Context<'_>) -> FieldResult<i32> {
        // 实现获取评论数量
        Ok(0)
    }
}

// GraphQL 输入类型
#[derive(InputObject)]
pub struct CreateArticleInput {
    pub title: String,
    pub content: String,
    pub excerpt: Option<String>,
    pub image_url: Option<String>,
    pub category_id: Option<i64>,
    pub tag_ids: Option<Vec<i64>>,
    pub status: Option<ArticleStatus>,
}

#[derive(InputObject)]
pub struct UpdateArticleInput {
    pub title: Option<String>,
    pub content: Option<String>,
    pub excerpt: Option<String>,
    pub image_url: Option<String>,
    pub category_id: Option<i64>,
    pub tag_ids: Option<Vec<i64>>,
    pub status: Option<ArticleStatus>,
}

#[derive(InputObject)]
pub struct CreateCategoryInput {
    pub name: String,
    pub slug: String,
    pub description: Option<String>,
}

#[derive(InputObject)]
pub struct CreateTagInput {
    pub name: String,
    pub slug: String,
}

#[derive(InputObject)]
pub struct ArticleFilter {
    pub status: Option<ArticleStatus>,
    pub category_id: Option<i64>,
    pub tag_ids: Option<Vec<i64>>,
    pub author_id: Option<i64>,
    pub search: Option<String>,
}

#[derive(InputObject)]
pub struct Pagination {
    pub page: Option<i32>,
    pub per_page: Option<i32>,
}

#[derive(SimpleObject)]
pub struct ArticleConnection {
    pub articles: Vec<Article>,
    pub total: i32,
    pub page: i32,
    pub per_page: i32,
    pub total_pages: i32,
}

// 评论相关的数据结构
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommentAuthor {
    pub name: String,
    pub email: String,
    pub picture: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, SimpleObject)]
#[graphql(complex)]
pub struct Comment {
    pub id: String,
    pub content: String,
    pub author: CommentAuthor,
    #[serde(rename = "createdAt")]
    pub created_at: DateTime<Utc>,
    pub timestamp: String,         // 用于兼容前端
    pub parent_id: Option<String>, // 父评论ID，用于回复功能
    pub article_id: Option<String>, // 文章ID
    pub upvotes: i32,              // 点赞数
    pub downvotes: i32,            // 点踩数
    pub user_vote: Option<String>, // 当前用户的投票状态 ("up", "down", null)
    pub replies: Vec<Comment>,     // 回复列表
}

#[ComplexObject]
impl Comment {
    async fn article(&self, ctx: &Context<'_>) -> FieldResult<Option<Article>> {
        // 实现获取评论所属文章
        Ok(None)
    }
}

#[derive(Deserialize)]
pub struct CreateCommentPayload {
    pub content: String,
    pub author: CommentAuthor,
    pub parent_id: Option<String>, // 父评论ID
    pub article_id: Option<String>, // 文章ID
}

#[derive(Deserialize)]
pub struct VotePayload {
    pub comment_id: String,
    pub vote_type: String, // "up", "down", "remove"
    pub user_email: String,
}

#[derive(Serialize)]
pub struct CommentsResponse {
    pub comments: Vec<Comment>,
}

#[derive(Serialize)]
pub struct VoteResponse {
    pub upvotes: i32,
    pub downvotes: i32,
    pub user_vote: Option<String>,
}

// REST API 响应类型
#[derive(Serialize)]
pub struct ArticleResponse {
    pub article: Article,
}

#[derive(Serialize)]
pub struct ArticlesResponse {
    pub articles: Vec<Article>,
    pub total: i32,
    pub page: i32,
    pub per_page: i32,
}

#[derive(Serialize)]
pub struct CategoriesResponse {
    pub categories: Vec<Category>,
}

#[derive(Serialize)]
pub struct TagsResponse {
    pub tags: Vec<Tag>,
}
```
 代码
```rust
// ## src/graphql/schema.rs
use async_graphql::*;
use deadpool_postgres::Pool;

use crate::database::*;
use crate::services::{article_service, category_service, tag_service};

pub type BlogSchema = Schema<QueryRoot, MutationRoot, EmptySubscription>;

// GraphQL Context
pub struct GraphQLContext {
    pub pool: Pool,
    pub current_user: Option<User>,
}

impl GraphQLContext {
    pub fn new(pool: Pool, current_user: Option<User>) -> Self {
        Self { pool, current_user }
    }
}

// Query Root
pub struct QueryRoot;

#[Object]
impl QueryRoot {
    // 文章查询
    async fn articles(
        &self,
        ctx: &Context<'_>,
        filter: Option<ArticleFilter>,
        pagination: Option<Pagination>,
    ) -> FieldResult<ArticleConnection> {
        let context = ctx.data::<GraphQLContext>()?;
        let filter = filter.unwrap_or_default();
        let pagination = pagination.unwrap_or_default();
        
        let page = pagination.page.unwrap_or(1).max(1);
        let per_page = pagination.per_page.unwrap_or(10).max(1).min(100);
        
        let result = article_service::get_articles_paginated(
            &context.pool,
            &filter,
            page,
            per_page,
        ).await?;
        
        Ok(result)
    }

    async fn article(&self, ctx: &Context<'_>, id: Option<String>, slug: Option<String>) -> FieldResult<Option<Article>> {
        let context = ctx.data::<GraphQLContext>()?;
        
        if let Some(id) = id {
            Ok(article_service::get_article_by_id(&context.pool, &id).await?)
        } else if let Some(slug) = slug {
            Ok(article_service::get_article_by_slug(&context.pool, &slug).await?)
        } else {
            Err("必须提供 id 或 slug 参数".into())
        }
    }

    // 分类查询
    async fn categories(&self, ctx: &Context<'_>) -> FieldResult<Vec<Category>> {
        let context = ctx.data::<GraphQLContext>()?;
        Ok(category_service::get_all_categories(&context.pool).await?)
    }

    async fn category(&self, ctx: &Context<'_>, id: Option<i64>, slug: Option<String>) -> FieldResult<Option<Category>> {
        let context = ctx.data::<GraphQLContext>()?;
        
        if let Some(id) = id {
            Ok(category_service::get_category_by_id(&context.pool, id).await?)
        } else if let Some(slug) = slug {
            Ok(category_service::get_category_by_slug(&context.pool, &slug).await?)
        } else {
            Err("必须提供 id 或 slug 参数".into())
        }
    }

    // 标签查询
    async fn tags(&self, ctx: &Context<'_>) -> FieldResult<Vec<Tag>> {
        let context = ctx.data::<GraphQLContext>()?;
        Ok(tag_service::get_all_tags(&context.pool).await?)
    }

    async fn tag(&self, ctx: &Context<'_>, id: Option<i64>, slug: Option<String>) -> FieldResult<Option<Tag>> {
        let context = ctx.data::<GraphQLContext>()?;
        
        if let Some(id) = id {
            Ok(tag_service::get_tag_by_id(&context.pool, id).await?)
        } else if let Some(slug) = slug {
            Ok(tag_service::get_tag_by_slug(&context.pool, &slug).await?)
        } else {
            Err("必须提供 id 或 slug 参数".into())
        }
    }

    // 搜索
    async fn search_articles(
        &self,
        ctx: &Context<'_>,
        query: String,
        pagination: Option<Pagination>,
    ) -> FieldResult<ArticleConnection> {
        let context = ctx.data::<GraphQLContext>()?;
        let pagination = pagination.unwrap_or_default();
        
        let page = pagination.page.unwrap_or(1).max(1);
        let per_page = pagination.per_page.unwrap_or(10).max(1).min(100);
        
        let filter = ArticleFilter {
            search: Some(query),
            ..Default::default()
        };
        
        let result = article_service::get_articles_paginated(
            &context.pool,
            &filter,
            page,
            per_page,
        ).await?;
        
        Ok(result)
    }
}

// Mutation Root
pub struct MutationRoot;

#[Object]
impl MutationRoot {
    // 文章操作
    async fn create_article(
        &self,
        ctx: &Context<'_>,
        input: CreateArticleInput,
    ) -> FieldResult<Article> {
        let context = ctx.data::<GraphQLContext>()?;
        
        let user = context.current_user.as_ref()
            .ok_or("需要登录才能创建文章")?;
            
        Ok(article_service::create_article(&context.pool, input, user.id).await?)
    }

    async fn update_article(
        &self,
        ctx: &Context<'_>,
        id: String,
        input: UpdateArticleInput,
    ) -> FieldResult<Article> {
        let context = ctx.data::<GraphQLContext>()?;
        
        let user = context.current_user.as_ref()
            .ok_or("需要登录才能更新文章")?;
            
        Ok(article_service::update_article(&context.pool, &id, input, user.id).await?)
    }

    async fn delete_article(&self, ctx: &Context<'_>, id: String) -> FieldResult<bool> {
        let context = ctx.data::<GraphQLContext>()?;
        
        let user = context.current_user.as_ref()
            .ok_or("需要登录才能删除文章")?;
            
        Ok(article_service::delete_article(&context.pool, &id, user.id).await?)
    }

    async fn publish_article(&self, ctx: &Context<'_>, id: String) -> FieldResult<Article> {
        let context = ctx.data::<GraphQLContext>()?;
        
        let user = context.current_user.as_ref()
            .ok_or("需要登录才能发布文章")?;
            
        Ok(article_service::publish_article(&context.pool, &id, user.id).await?)
    }

    // 分类操作
    async fn create_category(
        &self,
        ctx: &Context<'_>,
        input: CreateCategoryInput,
    ) -> FieldResult<Category> {
        let context = ctx.data::<GraphQLContext>()?;
        
        context.current_user.as_ref()
            .ok_or("需要登录才能创建分类")?;
            
        Ok(category_service::create_category(&context.pool, input).await?)
    }

    // 标签操作
    async fn create_tag(
        &self,
        ctx: &Context<'_>,
        input: CreateTagInput,
    ) -> FieldResult<Tag> {
        let context = ctx.data::<GraphQLContext>()?;
        
        context.current_user.as_ref()
            .ok_or("需要登录才能创建标签")?;
            
        Ok(tag_service::create_tag(&context.pool, input).await?)
    }
}

// 默认实现
impl Default for ArticleFilter {
    fn default() -> Self {
        Self {
            status: None,
            category_id: None,
            tag_ids: None,
            author_id: None,
            search: None,
        }
    }
}

impl Default for Pagination {
    fn default() -> Self {
        Self {
            page: Some(1),
            per_page: Some(10),
        }
    }
}

pub fn create_schema(pool: Pool) -> BlogSchema {
    Schema::build(QueryRoot, MutationRoot, EmptySubscription)
        .data(pool)
        .finish()
}
```
 代码
```rust
// ## src/graphql/mod.rs
pub mod schema;

pub use schema::*;
```
 代码
```rust
// ## src/services/article_service.rs
use crate::database::*;
use chrono::Utc;
use deadpool_postgres::Pool;
use uuid::Uuid;

pub async fn get_articles_paginated(
    pool: &Pool,
    filter: &ArticleFilter,
    page: i32,
    per_page: i32,
) -> Result<ArticleConnection, Box<dyn std::error::Error>> {
    let client = pool.get().await?;
    let offset = (page - 1) * per_page;

    // 构建查询条件
    let mut where_clauses = vec!["1=1".to_string()];
    let mut params: Vec<&(dyn tokio_postgres::types::ToSql + Sync)> = vec![];
    let mut param_count = 0;

    // 状态过滤
    if let Some(status) = &filter.status {
        param_count += 1;
        where_clauses.push(format!("a.status = ${}", param_count));
        params.push(&String::from(*status));
    }

    // 分类过滤
    if let Some(category_id) = filter.category_id {
        param_count += 1;
        where_clauses.push(format!("a.category_id = ${}", param_count));
        params.push(&category_id);
    }

    // 作者过滤
    if let Some(author_id) = filter.author_id {
        param_count += 1;
        where_clauses.push(format!("a.author_id = ${}", param_count));
        params.push(&author_id);
    }

    // 搜索过滤
    if let Some(search) = &filter.search {
        param_count += 1;
        where_clauses.push(format!(
            "(a.title ILIKE ${} OR a.content ILIKE ${} OR a.excerpt ILIKE ${})",
            param_count, param_count, param_count
        ));
        let search_pattern = format!("%{}%", search);
        params.push(&search_pattern);
    }

    let where_clause = where_clauses.join(" AND ");

    // 查询总数
    let count_query = format!(
        "SELECT COUNT(*) FROM articles a WHERE {}",
        where_clause
    );
    let total_row = client.query_one(&count_query, &params).await?;
    let total: i64 = total_row.get(0);

    // 查询文章
    param_count += 1;
    params.push(&per_page);
    param_count += 1;
    params.push(&offset);

    let query = format!(
        "SELECT a.id, a.title, a.slug, a.content, a.excerpt, a.image_url, 
                a.status, a.view_count, a.created_at, a.updated_at, a.published_at
         FROM articles a 
         WHERE {} 
         ORDER BY COALESCE(a.published_at, a.created_at) DESC 
         LIMIT ${} OFFSET ${}",
        where_clause, param_count - 1, param_count
    );

    let rows = client.query(&query, &params).await?;
    let mut articles = Vec::new();

    for row in rows {
        let status_str: String = row.get(6);
        articles.push(Article {
            id: row.get(0),
            title: row.get(1),
            slug: row.get(2),
            content: row.get(3),
            excerpt: row.get(4),
            image_url: row.get(5),
            status: ArticleStatus::from(status_str),
            view_count: row.get(7),
            created_at: row.get(8),
            updated_at: row.get(9),
            published_at: row.get(10),
        });
    }

    let total_pages = ((total as f64) / (per_page as f64)).ceil() as i32;

    Ok(ArticleConnection {
        articles,
        total: total as i32,
        page,
        per_page,
        total_pages,
    })
}

pub async fn get_article_by_id(
    pool: &Pool,
    id: &str,
) -> Result<Option<Article>, Box<dyn std::error::Error>> {
    let client = pool.get().await?;
    
    let row = client
        .query_opt(
            "SELECT id, title, slug, content, excerpt, image_url, status, view_count,
                    created_at, updated_at, published_at
             FROM articles WHERE id = $1",
            &[&id],
        )
        .await?;

    if let Some(row) = row {
        let status_str: String = row.get(6);
        Ok(Some(Article {
            id: row.get(0),
            title: row.get(1),
            slug: row.get(2),
            content: row.get(3),
            excerpt: row.get(4),
            image_url: row.get(5),
            status: ArticleStatus::from(status_str),
            view_count: row.get(7),
            created_at: row.get(8),
            updated_at: row.get(9),
            published_at: row.get(10),
        }))
    } else {
        Ok(None)
    }
}

pub async fn get_article_by_slug(
    pool: &Pool,
    slug: &str,
) -> Result<Option<Article>, Box<dyn std::error::Error>> {
    let client = pool.get().await?;
    
    let row = client
        .query_opt(
            "SELECT id, title, slug, content, excerpt, image_url, status, view_count,
                    created_at, updated_at, published_at
             FROM articles WHERE slug = $1",
            &[&slug],
        )
        .await?;

    if let Some(row) = row {
        let status_str: String = row.get(6);
        Ok(Some(Article {
            id: row.get(0),
            title: row.get(1),
            slug: row.get(2),
            content: row.get(3),
            excerpt: row.get(4),
            image_url: row.get(5),
            status: ArticleStatus::from(status_str),
            view_count: row.get(7),
            created_at: row.get(8),
            updated_at: row.get(9),
            published_at: row.get(10),
        }))
    } else {
        Ok(None)
    }
}

pub async fn create_article(
    pool: &Pool,
    input: CreateArticleInput,
    author_id: i64,
) -> Result<Article, Box<dyn std::error::Error>> {
    let client = pool.get().await?;
    let now = Utc::now();
    let article_id = Uuid::new_v4().to_string();
    
    // 生成 slug
    let slug = generate_slug(&input.title);
    
    // 检查 slug 是否唯一
    let unique_slug = ensure_unique_slug(pool, &slug).await?;
    
    let status = input.status.unwrap_or(ArticleStatus::Draft);
    let status_str = String::from(status);
    
    let published_at = if status == ArticleStatus::Published {
        Some(now)
    } else {
        None
    };

    // 插入文章
    client
        .execute(
            "INSERT INTO articles (id, title, slug, content, excerpt, image_url, 
                                  category_id, author_id, status, created_at, updated_at, published_at)
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)",
            &[
                &article_id,
                &input.title,
                &unique_slug,
                &input.content,
                &input.excerpt,
                &input.image_url,
                &input.category_id,
                &author_id,
                &status_str,
                &now,
                &now,
                &published_at,
            ],
        )
        .await?;

    // 关联标签
    if let Some(tag_ids) = input.tag_ids {
        for tag_id in tag_ids {
            client
                .execute(
                    "INSERT INTO article_tags (article_id, tag_id) VALUES ($1, $2)",
                    &[&article_id, &tag_id],
                )
                .await?;
        }
    }

    Ok(Article {
        id: article_id,
        title: input.title,
        slug: unique_slug,
        content: input.content,
        excerpt: input.excerpt,
        image_url: input.image_url,
        status,
        view_count: 0,
        created_at: now,
        updated_at: now,
        published_at,
    })
}

pub async fn update_article(
    pool: &Pool,
    id: &str,
    input: UpdateArticleInput,
    author_id: i64,
) -> Result<Article, Box<dyn std::error::Error>> {
    let client = pool.get().await?;
    let now = Utc::now();

    // 检查文章是否存在且属于当前用户
    let row = client
        .query_opt(
            "SELECT author_id FROM articles WHERE id = $1",
            &[&id],
        )
        .await?;

    if let Some(row) = row {
        let article_author_id: i64 = row.get(0);
        if article_author_id != author_id {
            return Err("无权限编辑此文章".into());
        }
    } else {
        return Err("文章不存在".into());
    }

    // 构建更新查询
    let mut set_clauses = vec!["updated_at = $1".to_string()];
    let mut params: Vec<&(dyn tokio_postgres::types::ToSql + Sync)> = vec![&now];
    let mut param_count = 1;

    if let Some(title) = &input.title {
        param_count += 1;
        set_clauses.push(format!("title = ${}", param_count));
        params.push(title);
        
        // 如果标题更新，也更新 slug
        param_count += 1;
        let new_slug = generate_slug(title);
        let unique_slug = ensure_unique_slug(pool, &new_slug).await?;
        set_clauses.push(format!("slug = ${}", param_count));
        params.push(&unique_slug);
    }

    if let Some(content) = &input.content {
        param_count += 1;
        set_clauses.push(format!("content = ${}", param_count));
        params.push(content);
    }

    if let Some(excerpt) = &input.excerpt {
        param_count += 1;
        set_clauses.push(format!("excerpt = ${}", param_count));
        params.push(excerpt);
    }

    if let Some(image_url) = &input.image_url {
        param_count += 1;
        set_clauses.push(format!("image_url = ${}", param_count));
        params.push(image_url);
    }

    if let Some(category_id) = input.category_id {
        param_count += 1;
        set_clauses.push(format!("category_id = ${}", param_count));
        params.push(&category_id);
    }

    if let Some(status) = input.status {
        param_count += 1;
        let status_str = String::from(status);
        set_clauses.push(format!("status = ${}", param_count));
        params.push(&status_str);
        
        // 如果状态变为已发布，设置发布时间
        if status == ArticleStatus::Published {
            param_count += 1;
            set_clauses.push(format!("published_at = ${}", param_count));
            params.push(&now);
        }
    }

    param_count += 1;
    params.push(&id);

    let query = format!(
        "UPDATE articles SET {} WHERE id = ${}",
        set_clauses.join(", "),
        param_count
    );

    client.execute(&query, &params).await?;

    // 更新标签关联
    if let Some(tag_ids) = input.tag_ids {
        // 删除现有关联
        client
            .execute("DELETE FROM article_tags WHERE article_id = $1", &[&id])
            .await?;

        // 添加新关联
        for tag_id in tag_ids {
            client
                .execute(
                    "INSERT INTO article_tags (article_id, tag_id) VALUES ($1, $2)",
                    &[&id, &tag_id],
                )
                .await?;
        }
    }

    // 返回更新后的文章
    get_article_by_id(pool, id)
        .await?
        .ok_or_else(|| "文章更新后未找到".into())
}

pub async fn delete_article(
    pool: &Pool,
    id: &str,
    author_id: i64,
) -> Result<bool, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    // 检查文章是否存在且属于当前用户
    let row = client
        .query_opt(
            "SELECT author_id FROM articles WHERE id = $1",
            &[&id],
        )
        .await?;

    if let Some(row) = row {
        let article_author_id: i64 = row.get(0);
        if article_author_id != author_id {
            return Err("无权限删除此文章".into());
        }
    } else {
        return Ok(false);
    }

    let rows_affected = client
        .execute("DELETE FROM articles WHERE id = $1", &[&id])
        .await?;

    Ok(rows_affected > 0)
}

pub async fn publish_article(
    pool: &Pool,
    id: &str,
    author_id: i64,
) -> Result<Article, Box<dyn std::error::Error>> {
    let input = UpdateArticleInput {
        status: Some(ArticleStatus::Published),
        ..Default::default()
    };
    
    update_article(pool, id, input, author_id).await
}

pub async fn increment_view_count(
    pool: &Pool,
    id: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let client = pool.get().await?;
    
    client
        .execute(
            "UPDATE articles SET view_count = view_count + 1 WHERE id = $1",
            &[&id],
        )
        .await?;

    Ok(())
}

// 工具函数
fn generate_slug(title: &str) -> String {
    title
        .trim()
        .to_lowercase()
        .chars()
        .map(|c| match c {
            'a'..='z' | '0'..='9' => c,
            ' ' | '-' | '_' => '-',
            _ => '-',
        })
        .collect::<String>()
        .split('-')
        .filter(|s| !s.is_empty())
        .collect::<Vec<_>>()
        .join("-")
}

async fn ensure_unique_slug(
    pool: &Pool,
    base_slug: &str,
) -> Result<String, Box<dyn std::error::Error>> {
    let client = pool.get().await?;
    let mut slug = base_slug.to_string();
    let mut counter = 1;

    loop {
        let row = client
            .query_opt(
                "SELECT COUNT(*) FROM articles WHERE slug = $1",
                &[&slug],
            )
            .await?;

        if let Some(row) = row {
            let count: i64 = row.get(0);
            if count == 0 {
                break;
            }
        }

        slug = format!("{}-{}", base_slug, counter);
        counter += 1;
    }

    Ok(slug)
}

impl Default for UpdateArticleInput {
    fn default() -> Self {
        Self {
            title: None,
            content: None,
            excerpt: None,
            image_url: None,
            category_id: None,
            tag_ids: None,
            status: None,
        }
    }
}
```
 代码
```rust
// ## src/services/category_service.rs
use crate::database::*;
use chrono::Utc;
use deadpool_postgres::Pool;

pub async fn get_all_categories(
    pool: &Pool,
) -> Result<Vec<Category>, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    let rows = client
        .query(
            "SELECT id, name, slug, description, created_at 
             FROM categories 
             ORDER BY name ASC",
            &[],
        )
        .await?;

    let mut categories = Vec::new();
    for row in rows {
        categories.push(Category {
            id: row.get(0),
            name: row.get(1),
            slug: row.get(2),
            description: row.get(3),
            created_at: row.get(4),
        });
    }

    Ok(categories)
}

pub async fn get_category_by_id(
    pool: &Pool,
    id: i64,
) -> Result<Option<Category>, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    let row = client
        .query_opt(
            "SELECT id, name, slug, description, created_at 
             FROM categories 
             WHERE id = $1",
            &[&id],
        )
        .await?;

    if let Some(row) = row {
        Ok(Some(Category {
            id: row.get(0),
            name: row.get(1),
            slug: row.get(2),
            description: row.get(3),
            created_at: row.get(4),
        }))
    } else {
        Ok(None)
    }
}

pub async fn get_category_by_slug(
    pool: &Pool,
    slug: &str,
) -> Result<Option<Category>, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    let row = client
        .query_opt(
            "SELECT id, name, slug, description, created_at 
             FROM categories 
             WHERE slug = $1",
            &[&slug],
        )
        .await?;

    if let Some(row) = row {
        Ok(Some(Category {
            id: row.get(0),
            name: row.get(1),
            slug: row.get(2),
            description: row.get(3),
            created_at: row.get(4),
        }))
    } else {
        Ok(None)
    }
}

pub async fn create_category(
    pool: &Pool,
    input: CreateCategoryInput,
) -> Result<Category, Box<dyn std::error::Error>> {
    let client = pool.get().await?;
    let now = Utc::now();

    // 检查 slug 是否唯一
    let unique_slug = ensure_unique_slug(pool, &input.slug).await?;

    // 插入分类
    let row = client
        .query_one(
            "INSERT INTO categories (name, slug, description, created_at)
             VALUES ($1, $2, $3, $4)
             RETURNING id, name, slug, description, created_at",
            &[&input.name, &unique_slug, &input.description, &now],
        )
        .await?;

    Ok(Category {
        id: row.get(0),
        name: row.get(1),
        slug: row.get(2),
        description: row.get(3),
        created_at: row.get(4),
    })
}

pub async fn update_category(
    pool: &Pool,
    id: i64,
    input: CreateCategoryInput,
) -> Result<Option<Category>, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    // 检查分类是否存在
    let exists = client
        .query_opt("SELECT id FROM categories WHERE id = $1", &[&id])
        .await?;

    if exists.is_none() {
        return Ok(None);
    }

    // 如果 slug 有变化，检查唯一性
    let unique_slug = if input.slug != get_category_slug_by_id(pool, id).await? {
        ensure_unique_slug(pool, &input.slug).await?
    } else {
        input.slug
    };

    let row = client
        .query_one(
            "UPDATE categories 
             SET name = $1, slug = $2, description = $3
             WHERE id = $4
             RETURNING id, name, slug, description, created_at",
            &[&input.name, &unique_slug, &input.description, &id],
        )
        .await?;

    Ok(Some(Category {
        id: row.get(0),
        name: row.get(1),
        slug: row.get(2),
        description: row.get(3),
        created_at: row.get(4),
    }))
}

pub async fn delete_category(
    pool: &Pool,
    id: i64,
) -> Result<bool, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    // 检查是否有文章使用此分类
    let article_count_row = client
        .query_opt(
            "SELECT COUNT(*) FROM articles WHERE category_id = $1",
            &[&id],
        )
        .await?;

    if let Some(row) = article_count_row {
        let count: i64 = row.get(0);
        if count > 0 {
            return Err("无法删除包含文章的分类".into());
        }
    }

    let rows_affected = client
        .execute("DELETE FROM categories WHERE id = $1", &[&id])
        .await?;

    Ok(rows_affected > 0)
}

pub async fn get_categories_with_article_count(
    pool: &Pool,
) -> Result<Vec<(Category, i32)>, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    let rows = client
        .query(
            "SELECT c.id, c.name, c.slug, c.description, c.created_at,
                    COUNT(a.id) as article_count
             FROM categories c
             LEFT JOIN articles a ON c.id = a.category_id AND a.status = 'published'
             GROUP BY c.id, c.name, c.slug, c.description, c.created_at
             ORDER BY c.name ASC",
            &[],
        )
        .await?;

    let mut result = Vec::new();
    for row in rows {
        let category = Category {
            id: row.get(0),
            name: row.get(1),
            slug: row.get(2),
            description: row.get(3),
            created_at: row.get(4),
        };
        let article_count: i64 = row.get(5);
        result.push((category, article_count as i32));
    }

    Ok(result)
}

// 工具函数
async fn ensure_unique_slug(
    pool: &Pool,
    base_slug: &str,
) -> Result<String, Box<dyn std::error::Error>> {
    let client = pool.get().await?;
    let mut slug = base_slug.to_string();
    let mut counter = 1;

    loop {
        let row = client
            .query_opt(
                "SELECT COUNT(*) FROM categories WHERE slug = $1",
                &[&slug],
            )
            .await?;

        if let Some(row) = row {
            let count: i64 = row.get(0);
            if count == 0 {
                break;
            }
        }

        slug = format!("{}-{}", base_slug, counter);
        counter += 1;
    }

    Ok(slug)
}

async fn get_category_slug_by_id(
    pool: &Pool,
    id: i64,
) -> Result<String, Box<dyn std::error::Error>> {
    let client = pool.get().await?;
    
    let row = client
        .query_one("SELECT slug FROM categories WHERE id = $1", &[&id])
        .await?;
    
    Ok(row.get(0))
}
```
 代码
```rust
// ## src/services/tag_service.rs
use crate::database::*;
use chrono::Utc;
use deadpool_postgres::Pool;

pub async fn get_all_tags(
    pool: &Pool,
) -> Result<Vec<Tag>, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    let rows = client
        .query(
            "SELECT id, name, slug, created_at 
             FROM tags 
             ORDER BY name ASC",
            &[],
        )
        .await?;

    let mut tags = Vec::new();
    for row in rows {
        tags.push(Tag {
            id: row.get(0),
            name: row.get(1),
            slug: row.get(2),
            created_at: row.get(3),
        });
    }

    Ok(tags)
}

pub async fn get_tag_by_id(
    pool: &Pool,
    id: i64,
) -> Result<Option<Tag>, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    let row = client
        .query_opt(
            "SELECT id, name, slug, created_at 
             FROM tags 
             WHERE id = $1",
            &[&id],
        )
        .await?;

    if let Some(row) = row {
        Ok(Some(Tag {
            id: row.get(0),
            name: row.get(1),
            slug: row.get(2),
            created_at: row.get(3),
        }))
    } else {
        Ok(None)
    }
}

pub async fn get_tag_by_slug(
    pool: &Pool,
    slug: &str,
) -> Result<Option<Tag>, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    let row = client
        .query_opt(
            "SELECT id, name, slug, created_at 
             FROM tags 
             WHERE slug = $1",
            &[&slug],
        )
        .await?;

    if let Some(row) = row {
        Ok(Some(Tag {
            id: row.get(0),
            name: row.get(1),
            slug: row.get(2),
            created_at: row.get(3),
        }))
    } else {
        Ok(None)
    }
}

pub async fn create_tag(
    pool: &Pool,
    input: CreateTagInput,
) -> Result<Tag, Box<dyn std::error::Error>> {
    let client = pool.get().await?;
    let now = Utc::now();

    // 检查 slug 是否唯一
    let unique_slug = ensure_unique_slug(pool, &input.slug).await?;

    // 插入标签
    let row = client
        .query_one(
            "INSERT INTO tags (name, slug, created_at)
             VALUES ($1, $2, $3)
             RETURNING id, name, slug, created_at",
            &[&input.name, &unique_slug, &now],
        )
        .await?;

    Ok(Tag {
        id: row.get(0),
        name: row.get(1),
        slug: row.get(2),
        created_at: row.get(3),
    })
}

pub async fn update_tag(
    pool: &Pool,
    id: i64,
    input: CreateTagInput,
) -> Result<Option<Tag>, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    // 检查标签是否存在
    let exists = client
        .query_opt("SELECT id FROM tags WHERE id = $1", &[&id])
        .await?;

    if exists.is_none() {
        return Ok(None);
    }

    // 如果 slug 有变化，检查唯一性
    let unique_slug = if input.slug != get_tag_slug_by_id(pool, id).await? {
        ensure_unique_slug(pool, &input.slug).await?
    } else {
        input.slug
    };

    let row = client
        .query_one(
            "UPDATE tags 
             SET name = $1, slug = $2
             WHERE id = $3
             RETURNING id, name, slug, created_at",
            &[&input.name, &unique_slug, &id],
        )
        .await?;

    Ok(Some(Tag {
        id: row.get(0),
        name: row.get(1),
        slug: row.get(2),
        created_at: row.get(3),
    }))
}

pub async fn delete_tag(
    pool: &Pool,
    id: i64,
) -> Result<bool, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    // 先删除文章-标签关联
    client
        .execute("DELETE FROM article_tags WHERE tag_id = $1", &[&id])
        .await?;

    // 删除标签
    let rows_affected = client
        .execute("DELETE FROM tags WHERE id = $1", &[&id])
        .await?;

    Ok(rows_affected > 0)
}

pub async fn get_tags_with_article_count(
    pool: &Pool,
) -> Result<Vec<(Tag, i32)>, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    let rows = client
        .query(
            "SELECT t.id, t.name, t.slug, t.created_at,
                    COUNT(at.article_id) as article_count
             FROM tags t
             LEFT JOIN article_tags at ON t.id = at.tag_id
             LEFT JOIN articles a ON at.article_id = a.id AND a.status = 'published'
             GROUP BY t.id, t.name, t.slug, t.created_at
             ORDER BY t.name ASC",
            &[],
        )
        .await?;

    let mut result = Vec::new();
    for row in rows {
        let tag = Tag {
            id: row.get(0),
            name: row.get(1),
            slug: row.get(2),
            created_at: row.get(3),
        };
        let article_count: i64 = row.get(4);
        result.push((tag, article_count as i32));
    }

    Ok(result)
}

pub async fn get_tags_for_article(
    pool: &Pool,
    article_id: &str,
) -> Result<Vec<Tag>, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    let rows = client
        .query(
            "SELECT t.id, t.name, t.slug, t.created_at
             FROM tags t
             INNER JOIN article_tags at ON t.id = at.tag_id
             WHERE at.article_id = $1
             ORDER BY t.name ASC",
            &[&article_id],
        )
        .await?;

    let mut tags = Vec::new();
    for row in rows {
        tags.push(Tag {
            id: row.get(0),
            name: row.get(1),
            slug: row.get(2),
            created_at: row.get(3),
        });
    }

    Ok(tags)
}

pub async fn get_popular_tags(
    pool: &Pool,
    limit: i32,
) -> Result<Vec<(Tag, i32)>, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    let rows = client
        .query(
            "SELECT t.id, t.name, t.slug, t.created_at,
                    COUNT(at.article_id) as article_count
             FROM tags t
             INNER JOIN article_tags at ON t.id = at.tag_id
             INNER JOIN articles a ON at.article_id = a.id AND a.status = 'published'
             GROUP BY t.id, t.name, t.slug, t.created_at
             HAVING COUNT(at.article_id) > 0
             ORDER BY article_count DESC, t.name ASC
             LIMIT $1",
            &[&limit],
        )
        .await?;

    let mut result = Vec::new();
    for row in rows {
        let tag = Tag {
            id: row.get(0),
            name: row.get(1),
            slug: row.get(2),
            created_at: row.get(3),
        };
        let article_count: i64 = row.get(4);
        result.push((tag, article_count as i32));
    }

    Ok(result)
}

// 工具函数
async fn ensure_unique_slug(
    pool: &Pool,
    base_slug: &str,
) -> Result<String, Box<dyn std::error::Error>> {
    let client = pool.get().await?;
    let mut slug = base_slug.to_string();
    let mut counter = 1;

    loop {
        let row = client
            .query_opt(
                "SELECT COUNT(*) FROM tags WHERE slug = $1",
                &[&slug],
            )
            .await?;

        if let Some(row) = row {
            let count: i64 = row.get(0);
            if count == 0 {
                break;
            }
        }

        slug = format!("{}-{}", base_slug, counter);
        counter += 1;
    }

    Ok(slug)
}

async fn get_tag_slug_by_id(
    pool: &Pool,
    id: i64,
) -> Result<String, Box<dyn std::error::Error>> {
    let client = pool.get().await?;
    
    let row = client
        .query_one("SELECT slug FROM tags WHERE id = $1", &[&id])
        .await?;
    
    Ok(row.get(0))
}
```
 代码
```rust
// ## src/handlers/articles.rs
use crate::database::*;
use crate::handlers::DbPool;
use crate::services::{article_service, category_service, tag_service};
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    Json,
};
use serde::Deserialize;
use std::collections::HashMap;

#[derive(Deserialize)]
pub struct ArticleQueryParams {
    pub page: Option<i32>,
    pub per_page: Option<i32>,
    pub status: Option<String>,
    pub category: Option<String>,
    pub tag: Option<String>,
    pub author_id: Option<i64>,
    pub search: Option<String>,
}

// 获取文章列表
pub async fn get_articles(
    State(pool): State<DbPool>,
    Query(params): Query<ArticleQueryParams>,
) -> Result<Json<ArticleConnection>, (StatusCode, &'static str)> {
    println!("📰 获取文章列表");

    let page = params.page.unwrap_or(1).max(1);
    let per_page = params.per_page.unwrap_or(10).max(1).min(100);

    // 构建过滤器
    let mut filter = ArticleFilter {
        status: None,
        category_id: None,
        tag_ids: None,
        author_id: params.author_id,
        search: params.search,
    };

    // 状态过滤
    if let Some(status_str) = params.status {
        match status_str.as_str() {
            "published" => filter.status = Some(ArticleStatus::Published),
            "draft" => filter.status = Some(ArticleStatus::Draft),
            "archived" => filter.status = Some(ArticleStatus::Archived),
            _ => {}
        }
    }

    // 分类过滤
    if let Some(category_slug) = params.category {
        if let Ok(Some(category)) = category_service::get_category_by_slug(&pool, &category_slug).await {
            filter.category_id = Some(category.id);
        }
    }

    // 标签过滤
    if let Some(tag_slug) = params.tag {
        if let Ok(Some(tag)) = tag_service::get_tag_by_slug(&pool, &tag_slug).await {
            filter.tag_ids = Some(vec![tag.id]);
        }
    }

    match article_service::get_articles_paginated(&pool, &filter, page, per_page).await {
        Ok(result) => {
            println!("✅ 返回 {} 篇文章，共 {} 页", result.articles.len(), result.total_pages);
            Ok(Json(result))
        }
        Err(e) => {
            eprintln!("❌ 获取文章列表失败: {:?}", e);
            Err((StatusCode::INTERNAL_SERVER_ERROR, "获取文章列表失败"))
        }
    }
}

// 根据ID获取文章
pub async fn get_article_by_id(
    State(pool): State<DbPool>,
    Path(id): Path<String>,
) -> Result<Json<ArticleResponse>, (StatusCode, &'static str)> {
    println!("📰 获取文章: {}", id);

    match article_service::get_article_by_id(&pool, &id).await {
        Ok(Some(article)) => {
            // 增加浏览次数
            if let Err(e) = article_service::increment_view_count(&pool, &id).await {
                eprintln!("⚠️ 更新浏览次数失败: {:?}", e);
            }
            
            println!("✅ 文章找到: {}", article.title);
            Ok(Json(ArticleResponse { article }))
        }
        Ok(None) => {
            println!("❌ 文章不存在: {}", id);
            Err((StatusCode::NOT_FOUND, "文章不存在"))
        }
        Err(e) => {
            eprintln!("❌ 获取文章失败: {:?}", e);
            Err((StatusCode::INTERNAL_SERVER_ERROR, "获取文章失败"))
        }
    }
}

// 根据slug获取文章
pub async fn get_article_by_slug(
    State(pool): State<DbPool>,
    Path(slug): Path<String>,
) -> Result<Json<ArticleResponse>, (StatusCode, &'static str)> {
    println!("📰 根据slug获取文章: {}", slug);

    match article_service::get_article_by_slug(&pool, &slug).await {
        Ok(Some(article)) => {
            // 增加浏览次数
            if let Err(e) = article_service::increment_view_count(&pool, &article.id).await {
                eprintln!("⚠️ 更新浏览次数失败: {:?}", e);
            }
            
            println!("✅ 文章找到: {}", article.title);
            Ok(Json(ArticleResponse { article }))
        }
        Ok(None) => {
            println!("❌ 文章不存在: {}", slug);
            Err((StatusCode::NOT_FOUND, "文章不存在"))
        }
        Err(e) => {
            eprintln!("❌ 获取文章失败: {:?}", e);
            Err((StatusCode::INTERNAL_SERVER_ERROR, "获取文章失败"))
        }
    }
}

// 创建文章
pub async fn create_article(
    State(pool): State<DbPool>,
    Json(input): Json<CreateArticleInput>,
) -> Result<Json<ArticleResponse>, (StatusCode, &'static str)> {
    println!("📝 创建新文章: {}", input.title);

    // 这里应该从认证中间件获取用户信息
    // 暂时硬编码一个用户ID，实际应用中需要实现认证中间件
    let author_id = 1i64; // TODO: 从认证信息获取

    // 验证输入
    if input.title.trim().is_empty() {
        return Err((StatusCode::BAD_REQUEST, "文章标题不能为空"));
    }
    if input.content.trim().is_empty() {
        return Err((StatusCode::BAD_REQUEST, "文章内容不能为空"));
    }

    match article_service::create_article(&pool, input, author_id).await {
        Ok(article) => {
            println!("✅ 文章创建成功: {} ({})", article.title, article.id);
            Ok(Json(ArticleResponse { article }))
        }
        Err(e) => {
            eprintln!("❌ 创建文章失败: {:?}", e);
            Err((StatusCode::INTERNAL_SERVER_ERROR, "创建文章失败"))
        }
    }
}

// 更新文章
pub async fn update_article(
    State(pool): State<DbPool>,
    Path(id): Path<String>,
    Json(input): Json<UpdateArticleInput>,
) -> Result<Json<ArticleResponse>, (StatusCode, &'static str)> {
    println!("📝 更新文章: {}", id);

    // 这里应该从认证中间件获取用户信息
    let author_id = 1i64; // TODO: 从认证信息获取

    match article_service::update_article(&pool, &id, input, author_id).await {
        Ok(article) => {
            println!("✅ 文章更新成功: {}", article.title);
            Ok(Json(ArticleResponse { article }))
        }
        Err(e) => {
            eprintln!("❌ 更新文章失败: {:?}", e);
            if e.to_string().contains("无权限") {
                Err((StatusCode::FORBIDDEN, "无权限编辑此文章"))
            } else if e.to_string().contains("不存在") {
                Err((StatusCode::NOT_FOUND, "文章不存在"))
            } else {
                Err((StatusCode::INTERNAL_SERVER_ERROR, "更新文章失败"))
            }
        }
    }
}

// 删除文章
pub async fn delete_article(
    State(pool): State<DbPool>,
    Path(id): Path<String>,
) -> Result<Json<serde_json::Value>, (StatusCode, &'static str)> {
    println!("🗑️ 删除文章: {}", id);

    // 这里应该从认证中间件获取用户信息
    let author_id = 1i64; // TODO: 从认证信息获取

    match article_service::delete_article(&pool, &id, author_id).await {
        Ok(true) => {
            println!("✅ 文章删除成功: {}", id);
            Ok(Json(serde_json::json!({"message": "文章删除成功"})))
        }
        Ok(false) => {
            println!("❌ 文章不存在: {}", id);
            Err((StatusCode::NOT_FOUND, "文章不存在"))
        }
        Err(e) => {
            eprintln!("❌ 删除文章失败: {:?}", e);
            if e.to_string().contains("无权限") {
                Err((StatusCode::FORBIDDEN, "无权限删除此文章"))
            } else {
                Err((StatusCode::INTERNAL_SERVER_ERROR, "删除文章失败"))
            }
        }
    }
}

// 发布文章
pub async fn publish_article(
    State(pool): State<DbPool>,
    Path(id): Path<String>,
) -> Result<Json<ArticleResponse>, (StatusCode, &'static str)> {
    println!("📢 发布文章: {}", id);

    // 这里应该从认证中间件获取用户信息
    let author_id = 1i64; // TODO: 从认证信息获取

    match article_service::publish_article(&pool, &id, author_id).await {
        Ok(article) => {
            println!("✅ 文章发布成功: {}", article.title);
            Ok(Json(ArticleResponse { article }))
        }
        Err(e) => {
            eprintln!("❌ 发布文章失败: {:?}", e);
            if e.to_string().contains("无权限") {
                Err((StatusCode::FORBIDDEN, "无权限发布此文章"))
            } else if e.to_string().contains("不存在") {
                Err((StatusCode::NOT_FOUND, "文章不存在"))
            } else {
                Err((StatusCode::INTERNAL_SERVER_ERROR, "发布文章失败"))
            }
        }
    }
}

// 获取分类列表
pub async fn get_categories(
    State(pool): State<DbPool>,
) -> Result<Json<CategoriesResponse>, (StatusCode, &'static str)> {
    println!("📂 获取分类列表");

    match category_service::get_all_categories(&pool).await {
        Ok(categories) => {
            println!("✅ 返回 {} 个分类", categories.len());
            Ok(Json(CategoriesResponse { categories }))
        }
        Err(e) => {
            eprintln!("❌ 获取分类列表失败: {:?}", e);
            Err((StatusCode::INTERNAL_SERVER_ERROR, "获取分类列表失败"))
        }
    }
}

// 获取标签列表
pub async fn get_tags(
    State(pool): State<DbPool>,
) -> Result<Json<TagsResponse>, (StatusCode, &'static str)> {
    println!("🏷️ 获取标签列表");

    match tag_service::get_all_tags(&pool).await {
        Ok(tags) => {
            println!("✅ 返回 {} 个标签", tags.len());
            Ok(Json(TagsResponse { tags }))
        }
        Err(e) => {
            eprintln!("❌ 获取标签列表失败: {:?}", e);
            Err((StatusCode::INTERNAL_SERVER_ERROR, "获取标签列表失败"))
        }
    }
}
```
 代码
```rust
// ## src/handlers/graphql.rs
use crate::graphql::{BlogSchema, GraphQLContext};
use crate::handlers::DbPool;
use async_graphql::http::{playground_source, GraphQLPlaygroundConfig};
use async_graphql_axum::{GraphQLRequest, GraphQLResponse};
use axum::{
    extract::State,
    response::{Html, IntoResponse},
    Extension,
};

// GraphQL 查询处理器
pub async fn graphql_handler(
    State(pool): State<DbPool>,
    schema: Extension<BlogSchema>,
    req: GraphQLRequest,
) -> GraphQLResponse {
    println!("🔍 处理 GraphQL 请求");
    
    // 这里应该从认证中间件获取用户信息
    // 暂时使用 None，实际应用中需要实现认证中间件
    let current_user = None;
    
    let context = GraphQLContext::new(pool, current_user);
    
    schema.execute(req.into_inner().data(context)).await.into()
}

// GraphQL Playground 处理器
pub async fn graphql_playground() -> impl IntoResponse {
    Html(playground_source(GraphQLPlaygroundConfig::new("/graphql")))
}
```
 代码
```rust
// ## src/main.rs
mod config;
mod database;
mod handlers;
mod services;
mod utils;
mod graphql;

use axum::{
    routing::{get, post, put, delete},
    Router,
    Extension,
};
use std::net::SocketAddr;
use tokio::net::TcpListener;

use config::AppConfig;
use database::init::init_database;
use handlers::{auth, comments, health, articles, graphql as gql_handler};
use utils::cors::create_cors_layer;
use graphql::create_schema;

#[tokio::main]
async fn main() {
    println!("🚀 启动应用程序...");

    // 初始化配置
    let config = AppConfig::from_env();

    // 创建数据库连接池
    let pool = config.create_db_pool().expect("无法创建数据库连接池");

    // 初始化数据库
    if let Err(e) = init_database(&pool).await {
        eprintln!("❌ 数据库初始化失败: {:?}", e);
        std::process::exit(1);
    }
    println!("✅ 数据库初始化完成");

    // 创建 GraphQL Schema
    let schema = create_schema(pool.clone());
    println!("✅ GraphQL Schema 创建完成");

    // 创建路由
    let app = Router::new()
        // 健康检查
        .route("/", get(health::health_check))
        .route("/api/health", get(health::health_check))
        
        // 认证相关
        .route("/api/google-login", post(auth::handle_google_login))
        .route("/api/google-logout", post(auth::handle_google_logout))
        
        // 评论相关
        .route("/api/comments", get(comments::get_comments))
        .route("/api/comments", post(comments::create_comment))
        .route("/api/comments/vote", post(comments::handle_vote))
        
        // 文章相关 REST API
        .route("/api/articles", get(articles::get_articles))
        .route("/api/articles", post(articles::create_article))
        .route("/api/articles/:id", get(articles::get_article_by_id))
        .route("/api/articles/:id", put(articles::update_article))
        .route("/api/articles/:id", delete(articles::delete_article))
        .route("/api/articles/:id/publish", post(articles::publish_article))
        .route("/api/articles/slug/:slug", get(articles::get_article_by_slug))
        
        // 分类和标签
        .route("/api/categories", get(articles::get_categories))
        .route("/api/tags", get(articles::get_tags))
        
        // GraphQL
        .route("/graphql", post(gql_handler::graphql_handler))
        .route("/graphql", get(gql_handler::graphql_handler))
        .route("/playground", get(gql_handler::graphql_playground))
        
        // 添加状态和扩展
        .with_state(pool)
        .layer(Extension(schema))
        .layer(create_cors_layer());

    let addr = SocketAddr::from(([0, 0, 0, 0], config.port));

    println!("🚀 服务运行在 http://0.0.0.0:{}", config.port);
    println!("🔗 本地访问: http://localhost:{}", config.port);
    println!("🗄️ 使用 PostgreSQL 数据库: {}", config.db_name);
    println!();
    println!("📰 文章管理功能已启用:");
    println!("   • REST API: /api/articles");
    println!("   • GraphQL API: /graphql");
    println!("   • GraphQL Playground: /playground");
    println!();
    println!("💬 讨论区功能已启用:");
    println!("   • 评论系统: /api/comments");
    println!("   • 投票功能: /api/comments/vote");
    println!("   • 回复功能已启用");
    println!();
    println!("🏷️ 内容管理:");
    println!("   • 分类管理: /api/categories");
    println!("   • 标签管理: /api/tags");
    println!("   • Markdown 支持");
    println!("   • 文章状态管理 (草稿/发布/归档)");

    let listener = TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}
```

### 用户:
Continue
### 系统:
我来继续完善这个项目，添加一些重要的功能和配置文件。 代码
```rust
// ## src/services/comment_service.rs
use crate::database::{Comment, CommentAuthor, CreateCommentPayload};
use crate::services::vote_service;
use chrono::Utc;
use deadpool_postgres::Pool;
use uuid::Uuid;

pub fn validate_comment_payload(payload: &CreateCommentPayload) -> Result<(), &'static str> {
    let content = payload.content.trim();
    if content.is_empty() {
        return Err("评论内容不能为空");
    }
    if content.len() > 500 {
        return Err("评论内容不能超过500字符");
    }
    if payload.author.name.trim().is_empty() || payload.author.email.trim().is_empty() {
        return Err("用户信息不完整");
    }
    Ok(())
}

pub async fn get_all_comments(
    pool: &Pool,
    user_email: Option<&str>,
) -> Result<Vec<Comment>, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    let rows = client
        .query(
            "SELECT id, content, author_name, author_email, author_picture, created_at, parent_id, article_id
         FROM comments ORDER BY created_at ASC",
            &[],
        )
        .await?;

    let mut comments = Vec::new();

    for row in rows {
        let created_at = row.get(5);
        let mut comment = Comment {
            id: row.get(0),
            content: row.get(1),
            author: CommentAuthor {
                name: row.get(2),
                email: row.get(3),
                picture: row.get(4),
            },
            created_at,
            timestamp: created_at.to_rfc3339(),
            parent_id: row.get(6),
            article_id: row.get(7),
            upvotes: 0,
            downvotes: 0,
            user_vote: None,
            replies: Vec::new(),
        };

        // 获取投票信息
        if let Ok((upvotes, downvotes, user_vote)) =
            vote_service::get_comment_votes(pool, &comment.id, user_email).await
        {
            comment.upvotes = upvotes;
            comment.downvotes = downvotes;
            comment.user_vote = user_vote;
        }

        comments.push(comment);
    }

    Ok(comments)
}

pub async fn get_comments_for_article(
    pool: &Pool,
    article_id: &str,
    user_email: Option<&str>,
) -> Result<Vec<Comment>, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    let rows = client
        .query(
            "SELECT id, content, author_name, author_email, author_picture, created_at, parent_id, article_id
         FROM comments 
         WHERE article_id = $1 
         ORDER BY created_at ASC",
            &[&article_id],
        )
        .await?;

    let mut comments = Vec::new();

    for row in rows {
        let created_at = row.get(5);
        let mut comment = Comment {
            id: row.get(0),
            content: row.get(1),
            author: CommentAuthor {
                name: row.get(2),
                email: row.get(3),
                picture: row.get(4),
            },
            created_at,
            timestamp: created_at.to_rfc3339(),
            parent_id: row.get(6),
            article_id: row.get(7),
            upvotes: 0,
            downvotes: 0,
            user_vote: None,
            replies: Vec::new(),
        };

        // 获取投票信息
        if let Ok((upvotes, downvotes, user_vote)) =
            vote_service::get_comment_votes(pool, &comment.id, user_email).await
        {
            comment.upvotes = upvotes;
            comment.downvotes = downvotes;
            comment.user_vote = user_vote;
        }

        comments.push(comment);
    }

    // 构建评论树结构
    Ok(build_comment_tree(comments))
}

pub async fn create_new_comment(
    pool: &Pool,
    payload: CreateCommentPayload,
) -> Result<Comment, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    // 如果是回复，验证父评论是否存在
    if let Some(parent_id) = &payload.parent_id {
        let row = client
            .query_opt("SELECT COUNT(*) FROM comments WHERE id = $1", &[parent_id])
            .await?;
        if let Some(row) = row {
            let count: i64 = row.get(0);
            if count == 0 {
                return Err("父评论不存在".into());
            }
        }
    }

    // 如果指定了文章ID，验证文章是否存在
    if let Some(article_id) = &payload.article_id {
        let row = client
            .query_opt("SELECT COUNT(*) FROM articles WHERE id = $1", &[article_id])
            .await?;
        if let Some(row) = row {
            let count: i64 = row.get(0);
            if count == 0 {
                return Err("文章不存在".into());
            }
        }
    }

    let now = Utc::now();
    let comment_id = Uuid::new_v4().to_string();
    let content = payload.content.trim();

    // 保存评论到数据库
    client.execute(
        "INSERT INTO comments (id, content, author_name, author_email, author_picture, created_at, parent_id, article_id)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8)",
        &[
            &comment_id,
            &content,
            &payload.author.name,
            &payload.author.email,
            &payload.author.picture,
            &now,
            &payload.parent_id,
            &payload.article_id,
        ],
    ).await?;

    Ok(Comment {
        id: comment_id,
        content: content.to_string(),
        author: payload.author,
        created_at: now,
        timestamp: now.to_rfc3339(),
        parent_id: payload.parent_id,
        article_id: payload.article_id,
        upvotes: 0,
        downvotes: 0,
        user_vote: None,
        replies: Vec::new(),
    })
}

pub async fn delete_comment(
    pool: &Pool,
    comment_id: &str,
    user_email: &str,
) -> Result<bool, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    // 检查评论是否存在且属于当前用户
    let row = client
        .query_opt(
            "SELECT author_email FROM comments WHERE id = $1",
            &[&comment_id],
        )
        .await?;

    if let Some(row) = row {
        let author_email: String = row.get(0);
        if author_email != user_email {
            return Err("无权限删除此评论".into());
        }
    } else {
        return Ok(false);
    }

    let rows_affected = client
        .execute("DELETE FROM comments WHERE id = $1", &[&comment_id])
        .await?;

    Ok(rows_affected > 0)
}

pub async fn get_comment_count_for_article(
    pool: &Pool,
    article_id: &str,
) -> Result<i32, Box<dyn std::error::Error>> {
    let client = pool.get().await?;

    let row = client
        .query_one(
            "SELECT COUNT(*) FROM comments WHERE article_id = $1",
            &[&article_id],
        )
        .await?;

    Ok(row.get::<_, i64>(0) as i32)
}

// 构建评论树结构
fn build_comment_tree(comments: Vec<Comment>) -> Vec<Comment> {
    let mut comment_map = std::collections::HashMap::new();
    let mut root_comments = Vec::new();

    // 将所有评论放入 HashMap
    for comment in comments {
        comment_map.insert(comment.id.clone(), comment);
    }

    // 构建树结构
    let comment_ids: Vec<String> = comment_map.keys().cloned().collect();
    
    for comment_id in comment_ids {
        if let Some(mut comment) = comment_map.remove(&comment_id) {
            if let Some(parent_id) = &comment.parent_id {
                // 这是一个回复，添加到父评论的 replies 中
                if let Some(parent_comment) = comment_map.get_mut(parent_id) {
                    parent_comment.replies.push(comment);
                }
            } else {
                // 这是一个顶级评论
                root_comments.push(comment);
            }
        }
    }

    // 排序回复
    for comment in &mut root_comments {
        sort_replies(&mut comment.replies);
    }

    root_comments
}

fn sort_replies(replies: &mut Vec<Comment>) {
    replies.sort_by(|a, b| a.created_at.cmp(&b.created_at));
    for reply in replies {
        sort_replies(&mut reply.replies);
    }
}
```
 代码
```rust
// ## src/middleware/auth.rs
use crate::database::User;
use axum::{
    extract::{Request, State},
    http::{HeaderMap, StatusCode},
    middleware::Next,
    response::Response,
};
use deadpool_postgres::Pool;

// 可选的认证中间件 - 如果有认证信息则验证，没有则跳过
pub async fn optional_auth_middleware(
    State(pool): State<Pool>,
    headers: HeaderMap,
    mut request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let user = extract_user_from_headers(&pool, &headers).await;
    
    // 将用户信息添加到请求扩展中
    request.extensions_mut().insert(user);
    
    Ok(next.run(request).await)
}

// 必需的认证中间件 - 必须有有效的认证信息
pub async fn required_auth_middleware(
    State(pool): State<Pool>,
    headers: HeaderMap,
    mut request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let user = extract_user_from_headers(&pool, &headers).await;
    
    match user {
        Some(user) => {
            request.extensions_mut().insert(Some(user));
            Ok(next.run(request).await)
        }
        None => Err(StatusCode::UNAUTHORIZED),
    }
}

// 从请求头中提取用户信息
async fn extract_user_from_headers(
    pool: &Pool,
    headers: &HeaderMap,
) -> Option<User> {
    // 尝试从 Authorization header 获取 token
    if let Some(auth_header) = headers.get("authorization") {
        if let Ok(auth_str) = auth_header.to_str() {
            if auth_str.starts_with("Bearer ") {
                let token = &auth_str[7..];
                return verify_token_and_get_user(pool, token).await;
            }
        }
    }
    
    // 尝试从 Cookie 获取 session
    if let Some(cookie_header) = headers.get("cookie") {
        if let Ok(cookie_str) = cookie_header.to_str() {
            for cookie in cookie_str.split(';') {
                let cookie = cookie.trim();
                if cookie.starts_with("session=") {
                    let session_token = &cookie[8..];
                    return verify_session_and_get_user(pool, session_token).await;
                }
            }
        }
    }
    
    None
}

// 验证 JWT token 并获取用户信息
async fn verify_token_and_get_user(
    pool: &Pool,
    token: &str,
) -> Option<User> {
    // 这里应该实现 JWT token 验证逻辑
    // 1. 验证 token 签名
    // 2. 检查 token 是否过期
    // 3. 从 token 中提取用户 ID
    // 4. 从数据库获取用户信息
    
    // 暂时的示例实现 - 生产环境需要使用真实的 JWT 库
    if token == "demo_token" {
        if let Ok(client) = pool.get().await {
            if let Ok(row) = client.query_one(
                "SELECT id, google_id, email, name, picture, created_at, last_login 
                 FROM users WHERE id = 1",
                &[],
            ).await {
                return Some(User {
                    id: row.get(0),
                    google_id: row.get(1),
                    email: row.get(2),
                    name: row.get(3),
                    picture: row.get(4),
                    created_at: row.get(5),
                    last_login: row.get(6),
                });
            }
        }
    }
    
    None
}

// 验证 session 并获取用户信息
async fn verify_session_and_get_user(
    pool: &Pool,
    session_token: &str,
) -> Option<User> {
    // 这里应该实现 session 验证逻辑
    // 1. 从 Redis 或数据库中查找 session
    // 2. 检查 session 是否有效
    // 3. 获取用户信息
    
    // 暂时的示例实现
    if session_token.len() > 10 {
        // 简单的 session 验证逻辑
        return verify_token_and_get_user(pool, "demo_token").await;
    }
    
    None
}

// 从请求扩展中获取当前用户
pub fn get_current_user_from_request(request: &Request) -> Option<User> {
    request.extensions().get::<Option<User>>()?.clone()
}
```
 代码
```rust
// ## src/middleware/mod.rs
pub mod auth;

pub use auth::*;
```
 代码
```rust
// ## src/utils/helpers.rs
use chrono::{DateTime, Utc};
use regex::Regex;

/// 生成文章摘要
pub fn generate_excerpt(content: &str, max_length: usize) -> String {
    // 移除 Markdown 标记
    let cleaned_content = strip_markdown(content);
    
    // 截取指定长度
    if cleaned_content.len() <= max_length {
        cleaned_content
    } else {
        let truncated = &cleaned_content[..max_length];
        // 找到最后一个完整的单词
        if let Some(last_space) = truncated.rfind(' ') {
            format!("{}...", &truncated[..last_space])
        } else {
            format!("{}...", truncated)
        }
    }
}

/// 移除 Markdown 标记
pub fn strip_markdown(content: &str) -> String {
    let mut result = content.to_string();
    
    // 移除标题标记
    let header_re = Regex::new(r"^#{1,6}\s+").unwrap();
    result = header_re.replace_all(&result, "").to_string();
    
    // 移除粗体和斜体
    let bold_italic_re = Regex::new(r"\*{1,2}([^*]+)\*{1,2}").unwrap();
    result = bold_italic_re.replace_all(&result, "$1").to_string();
    
    // 移除代码块
    let code_block_re = Regex::new(r"```[^`]*```").unwrap();
    result = code_block_re.replace_all(&result, "").to_string();
    
    // 移除内联代码
    let inline_code_re = Regex::new(r"`([^`]+)`").unwrap();
    result = inline_code_re.replace_all(&result, "$1").to_string();
    
    // 移除链接
    let link_re = Regex::new(r"\[([^\]]+)\]\([^\)]+\)").unwrap();
    result = link_re.replace_all(&result, "$1").to_string();
    
    // 移除图片
    let image_re = Regex::new(r"!\[([^\]]*)\]\([^\)]+\)").unwrap();
    result = image_re.replace_all(&result, "$1").to_string();
    
    // 移除多余的空白字符
    let whitespace_re = Regex::new(r"\s+").unwrap();
    result = whitespace_re.replace_all(&result, " ").to_string();
    
    result.trim().to_string()
}

/// 生成 URL 友好的 slug
pub fn slugify(text: &str) -> String {
    let mut slug = text
        .trim()
        .to_lowercase()
        .chars()
        .map(|c| match c {
            'a'..='z' | '0'..='9' => c,
            ' ' | '-' | '_' => '-',
            'á' | 'à' | 'ä' | 'â' => 'a',
            'é' | 'è' | 'ë' | 'ê' => 'e',
            'í' | 'ì' | 'ï' | 'î' => 'i',
            'ó' | 'ò' | 'ö' | 'ô' => 'o',
            'ú' | 'ù' | 'ü' | 'û' => 'u',
            'ñ' => 'n',
            'ç' => 'c',
            _ => '-',
        })
        .collect::<String>();
    
    // 移除多余的连字符
    let multiple_dash_re = Regex::new(r"-+").unwrap();
    slug = multiple_dash_re.replace_all(&slug, "-").to_string();
    
    // 移除开头和结尾的连字符
    slug.trim_matches('-').to_string()
}

/// 验证邮箱格式
pub fn is_valid_email(email: &str) -> bool {
    let email_re = Regex::new(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$").unwrap();
    email_re.is_match(email)
}

/// 格式化相对时间
pub fn format_relative_time(datetime: DateTime<Utc>) -> String {
    let now = Utc::now();
    let duration = now - datetime;
    
    let seconds = duration.num_seconds();
    let minutes = duration.num_minutes();
    let hours = duration.num_hours();
    let days = duration.num_days();
    
    if seconds < 60 {
        "刚刚".to_string()
    } else if minutes < 60 {
        format!("{}分钟前", minutes)
    } else if hours < 24 {
        format!("{}小时前", hours)
    } else if days < 7 {
        format!("{}天前", days)
    } else if days < 30 {
        format!("{}周前", days / 7)
    } else if days < 365 {
        format!("{}个月前", days / 30)
    } else {
        format!("{}年前", days / 365)
    }
}

/// 验证文章标题
pub fn validate_article_title(title: &str) -> Result<(), &'static str> {
    let title = title.trim();
    if title.is_empty() {
        return Err("标题不能为空");
    }
    if title.len() > 200 {
        return Err("标题不能超过200个字符");
    }
    Ok(())
}

/// 验证文章内容
pub fn validate_article_content(content: &str) -> Result<(), &'static str> {
    let content = content.trim();
    if content.is_empty() {
        return Err("内容不能为空");
    }
    if content.len() > 50000 {
        return Err("内容不能超过50000个字符");
    }
    Ok(())
}

/// 计算阅读时间（分钟）
pub fn calculate_read_time(content: &str) -> u32 {
    let word_count = content.split_whitespace().count();
    // 假设平均阅读速度是每分钟200个词
    let read_time = (word_count as f64 / 200.0).ceil() as u32;
    std::cmp::max(1, read_time)
}

/// 生成随机字符串
pub fn generate_random_string(length: usize) -> String {
    use rand::{distributions::Alphanumeric, Rng};
    rand::thread_rng()
        .sample_iter(&Alphanumeric)
        .take(length)
        .map(char::from)
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_slugify() {
        assert_eq!(slugify("Hello World"), "hello-world");
        assert_eq!(slugify("Rust 编程语言"), "rust-");
        assert_eq!(slugify("  Multiple   Spaces  "), "multiple-spaces");
    }
    
    #[test]
    fn test_strip_markdown() {
        let markdown = "# Title\n\nThis is **bold** and *italic* text with `code`.";
        let stripped = strip_markdown(markdown);
        assert_eq!(stripped, "Title This is bold and italic text with code.");
    }
    
    #[test]
    fn test_generate_excerpt() {
        let content = "This is a long article content that should be truncated.";
        let excerpt = generate_excerpt(content, 20);
        assert_eq!(excerpt, "This is a long...");
    }
    
    #[test]
    fn test_is_valid_email() {
        assert!(is_valid_email("test@example.com"));
        assert!(!is_valid_email("invalid-email"));
        assert!(!is_valid_email("test@"));
    }
    
    #[test]
    fn test_calculate_read_time() {
        let content = "word ".repeat(400); // 400 words
        let read_time = calculate_read_time(&content);
        assert_eq!(read_time, 2); // 400 words / 200 words per minute = 2 minutes
    }
}
```
 代码
```dockerfile
# ## Dockerfile
# 使用官方 Rust 镜像作为构建环境
FROM rust:1.75 as builder

# 设置工作目录
WORKDIR /app

# 复制 Cargo.toml 和 Cargo.lock
COPY Cargo.toml Cargo.lock ./

# 创建一个虚拟的 main.rs 来缓存依赖
RUN mkdir src && echo "fn main() {}" > src/main.rs

# 构建依赖（这一层会被缓存）
RUN cargo build --release
RUN rm src/main.rs

# 复制源代码
COPY src ./src

# 构建应用
RUN cargo build --release

# 使用较小的基础镜像作为运行环境
FROM debian:bookworm-slim

# 安装运行时依赖
RUN apt-get update && apt-get install -y \
    ca-certificates \
    libssl3 \
    libpq5 \
    && rm -rf /var/lib/apt/lists/*

# 创建应用用户
RUN groupadd -r appuser && useradd -r -g appuser appuser

# 设置工作目录
WORKDIR /app

# 从构建镜像复制可执行文件
COPY --from=builder /app/target/release/blog-api /app/blog-api

# 更改文件所有者
RUN chown -R appuser:appuser /app

# 切换到应用用户
USER appuser

# 暴露端口
EXPOSE 3001

# 设置环境变量
ENV RUST_LOG=info
ENV PORT=3001

# 运行应用
CMD ["./blog-api"]
```
 代码
```yaml
# ## docker-compose.yml
version: '3.8'

services:
  # PostgreSQL 数据库
  postgres:
    image: postgres:15
    container_name: blog_postgres
    environment:
      POSTGRES_DB: blog_api
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres123
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Redis (可选，用于缓存和会话存储)
  redis:
    image: redis:7-alpine
    container_name: blog_redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Blog API 应用
  blog-api:
    build: .
    container_name: blog_api
    environment:
      # 数据库配置
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: postgres
      DB_PASSWORD: postgres123
      DB_NAME: blog_api
      
      # 应用配置
      PORT: 3001
      RUST_LOG: info
      
      # Redis 配置 (可选)
      REDIS_URL: redis://redis:6379
      
      # JWT 密钥 (生产环境应该使用更安全的密钥)
      JWT_SECRET: your-super-secret-jwt-key-change-in-production
    ports:
      - "3001:3001"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      # 开发时可以挂载源码进行热重载
      - ./src:/app/src:ro
    restart: unless-stopped

  # Nginx 反向代理 (可选)
  nginx:
    image: nginx:alpine
    container_name: blog_nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - blog-api
    restart: unless-stopped

volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local

networks:
  default:
    name: blog_network
```
 代码
```bash
# ## .env.example
# 复制此文件为 .env 并填入实际的配置值

# ======================
# 应用配置
# ======================
PORT=3001
RUST_LOG=info

# ======================
# 数据库配置
# ======================
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=your_db_password_here
DB_NAME=blog_api

# ======================
# Redis 配置 (可选)
# ======================
REDIS_URL=redis://localhost:6379

# ======================
# JWT 配置
# ======================
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
JWT_EXPIRATION=86400  # 24 hours in seconds

# ======================
# Google OAuth 配置
# ======================
GOOGLE_CLIENT_ID=your-google-oauth-client-id
GOOGLE_CLIENT_SECRET=your-google-oauth-client-secret

# ======================
# 文件上传配置
# ======================
UPLOAD_DIR=./uploads
MAX_FILE_SIZE=10485760  # 10MB in bytes
ALLOWED_FILE_TYPES=jpg,jpeg,png,gif,webp

# ======================
# 邮件配置 (可选)
# ======================
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USERNAME=your-email@gmail.com
SMTP_PASSWORD=your-app-password
FROM_EMAIL=noreply@yourdomain.com
FROM_NAME=Your Blog Name

# ======================
# 外部服务配置
# ======================
# Cloudinary (图片存储，可选)
CLOUDINARY_CLOUD_NAME=your-cloud-name
CLOUDINARY_API_KEY=your-api-key
CLOUDINARY_API_SECRET=your-api-secret

# Amazon S3 (文件存储，可选)
AWS_ACCESS_KEY_ID=your-access-key
AWS_SECRET_ACCESS_KEY=your-secret-key
AWS_REGION=us-east-1
S3_BUCKET_NAME=your-bucket-name

# ======================
# 安全配置
# ======================
# CORS 允许的域名，用逗号分隔
CORS_ORIGINS=http://localhost:3000,http://localhost:5173,https://yourdomain.com

# Session 密钥
SESSION_SECRET=your-session-secret-key-change-this

# ======================
# 缓存配置
# ======================
CACHE_TTL=3600  # 1 hour in seconds
ENABLE_CACHE=true

# ======================
# 监控和日志配置
# ======================
# Sentry (错误监控，可选)
SENTRY_DSN=your-sentry-dsn-url

# 日志级别 (trace, debug, info, warn, error)
LOG_LEVEL=info

# ======================
# 功能开关
# ======================
ENABLE_REGISTRATION=true
ENABLE_COMMENTS=true
ENABLE_VOTING=true
ENABLE_EMAIL_NOTIFICATIONS=false

# ======================
# 速率限制配置
# ======================
RATE_LIMIT_REQUESTS_PER_MINUTE=60
RATE_LIMIT_BURST_SIZE=10

# ======================
# 搜索配置
# ======================
# Elasticsearch (可选)
ELASTICSEARCH_URL=http://localhost:9200
ENABLE_FULL_TEXT_SEARCH=false
```
 代码
```rust
// ## tests/integration_tests.rs
use axum::{
    body::Body,
    http::{Method, Request, StatusCode},
    Router,
};
use serde_json::{json, Value};
use tower::ServiceExt;

// 注意：这些测试需要运行中的数据库
// 在实际项目中，你可能想要使用测试数据库或者 mock

#[tokio::test]
async fn test_health_check() {
    let app = create_test_app().await;

    let response = app
        .oneshot(
            Request::builder()
                .uri("/api/health")
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);
}

#[tokio::test]
async fn test_get_articles() {
    let app = create_test_app().await;

    let response = app
        .oneshot(
            Request::builder()
                .uri("/api/articles")
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);
}

#[tokio::test]
async fn test_get_categories() {
    let app = create_test_app().await;

    let response = app
        .oneshot(
            Request::builder()
                .uri("/api/categories")
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);
}

#[tokio::test]
async fn test_create_article() {
    let app = create_test_app().await;

    let article_data = json!({
        "title": "Test Article",
        "content": "This is a test article content.",
        "excerpt": "Test excerpt",
        "status": "DRAFT"
    });

    let response = app
        .oneshot(
            Request::builder()
                .method(Method::POST)
                .uri("/api/articles")
                .header("content-type", "application/json")
                .body(Body::from(article_data.to_string()))
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);
}

#[tokio::test]
async fn test_graphql_query() {
    let app = create_test_app().await;

    let query = json!({
        "query": "query { articles { articles { id title } } }"
    });

    let response = app
        .oneshot(
            Request::builder()
                .method(Method::POST)
                .uri("/graphql")
                .header("content-type", "application/json")
                .body(Body::from(query.to_string()))
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);
}

#[tokio::test]
async fn test_invalid_article_creation() {
    let app = create_test_app().await;

    let invalid_data = json!({
        "title": "", // 空标题应该失败
        "content": "Some content"
    });

    let response = app
        .oneshot(
            Request::builder()
                .method(Method::POST)
                .uri("/api/articles")
                .header("content-type", "application/json")
                .body(Body::from(invalid_data.to_string()))
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::BAD_REQUEST);
}

#[tokio::test]
async fn test_cors_headers() {
    let app = create_test_app().await;

    let response = app
        .oneshot(
            Request::builder()
                .method(Method::OPTIONS)
                .uri("/api/articles")
                .header("origin", "http://localhost:3000")
                .header("access-control-request-method", "POST")
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);
    
    // 检查 CORS 头是否存在
    assert!(response.headers().contains_key("access-control-allow-origin"));
}

// 辅助函数：创建测试应用
async fn create_test_app() -> Router {
    // 这里应该创建一个测试版本的应用
    // 在实际实现中，你需要：
    // 1. 使用测试数据库
    // 2. 可能需要 mock 一些外部服务
    // 3. 设置测试特定的配置
    
    todo!("需要实现测试应用的创建逻辑")
}

// 辅助函数：清理测试数据
async fn cleanup_test_data() {
    // 清理测试过程中创建的数据
    todo!("实现测试数据清理")
}

// 测试数据库连接
#[tokio::test]
async fn test_database_connection() {
    // 测试数据库连接是否正常
    todo!("实现数据库连接测试")
}

// 测试用户认证流程
#[tokio::test]
async fn test_authentication_flow() {
    // 测试用户登录、token 验证等
    todo!("实现认证流程测试")
}

// 测试文章的完整 CRUD 操作
#[tokio::test]
async fn test_article_crud_operations() {
    // 测试创建、读取、更新、删除文章的完整流程
    todo!("实现文章 CRUD 测试")
}

// 性能测试：大量文章查询
#[tokio::test]
async fn test_large_article_query_performance() {
    // 测试在大量数据下的查询性能
    todo!("实现性能测试")
}

// 测试 GraphQL 错误处理
#[tokio::test]
async fn test_graphql_error_handling() {
    // 测试 GraphQL 查询的错误处理
    todo!("实现 GraphQL 错误处理测试")
}
```
 代码
```makefile
# ## Makefile
.PHONY: help dev build test clean docker-build docker-up docker-down setup migrate lint fmt check docs

# 默认目标
help: ## 显示帮助信息
	@echo "可用的命令:"
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-20s\033[0m %s\n", $$1, $$2}'

# 开发相关
dev: ## 启动开发服务器 (带热重载)
	cargo watch -x run

build: ## 构建项目
	cargo build --release

build-debug: ## 构建调试版本
	cargo build

run: ## 运行项目
	cargo run

# 测试相关
test: ## 运行所有测试
	cargo test

test-unit: ## 运行单元测试
	cargo test --lib

test-integration: ## 运行集成测试
	cargo test --test integration_tests

test-coverage: ## 生成测试覆盖率报告
	cargo tarpaulin --out Html --output-dir coverage

# 代码质量
lint: ## 运行 clippy 检查代码质量
	cargo clippy -- -D warnings

fmt: ## 格式化代码
	cargo fmt

fmt-check: ## 检查代码格式
	cargo fmt -- --check

check: ## 检查代码 (编译检查)
	cargo check

audit: ## 安全审计
	cargo audit

# 数据库相关
setup-db: ## 创建数据库
	createdb blog_api || true

drop-db: ## 删除数据库
	dropdb blog_api || true

reset-db: drop-db setup-db ## 重置数据库

migrate: ## 运行数据库迁移 (自动执行)
	cargo run

psql: ## 连接到 PostgreSQL
	psql -d blog_api

# Docker 相关
docker-build: ## 构建 Docker 镜像
	docker build -t blog-api .

docker-up: ## 启动 Docker 容器
	docker-compose up -d

docker-down: ## 停止 Docker 容器
	docker-compose down

docker-logs: ## 查看 Docker 日志
	docker-compose logs -f blog-api

docker-clean: ## 清理 Docker 资源
	docker-compose down -v
	docker system prune -f

# 环境设置
setup: ## 初始化开发环境
	@echo "🔧 设置开发环境..."
	@if [ ! -f .env ]; then cp .env.example .env; echo "✅ 创建 .env 文件"; fi
	cargo install cargo-watch cargo-tarpaulin cargo-audit
	@echo "✅ 开发环境设置完成"

install-deps: ## 安装开发依赖
	cargo install cargo-watch cargo-tarpaulin cargo-audit sqlx-cli

# 部署相关
deploy-staging: ## 部署到测试环境
	@echo "🚀 部署到测试环境..."
	docker build -t blog-api:staging .
	# 这里添加你的部署脚本

deploy-prod: ## 部署到生产环境
	@echo "🚀 部署到生产环境..."
	docker build -t blog-api:prod .
	# 这里添加你的生产部署脚本

# 文档相关
docs: ## 生成文档
	cargo doc --open

docs-build: ## 构建文档
	cargo doc --no-deps

# 数据相关
seed-data: ## 插入示例数据
	@echo "🌱 插入示例数据..."
	# 这里可以添加插入示例数据的脚本

backup-db: ## 备份数据库
	@echo "💾 备份数据库..."
	pg_dump blog_api > backup_$(shell date +%Y%m%d_%H%M%S).sql

restore-db: ## 恢复数据库 (需要指定 BACKUP_FILE)
	@if [ -z "$(BACKUP_FILE)" ]; then echo "请指定 BACKUP_FILE: make restore-db BACKUP_FILE=backup.sql"; exit 1; fi
	psql -d blog_api < $(BACKUP_FILE)

# 清理
clean: ## 清理构建产物
	cargo clean
	rm -rf target/
	rm -rf coverage/

clean-all: clean docker-clean ## 清理所有内容

# 安全检查
security-check: audit ## 运行安全检查
	@echo "🔒 运行安全检查..."

# 性能测试
bench: ## 运行性能基准测试
	cargo bench

# 开发工具
watch-test: ## 监听文件变化并运行测试
	cargo watch -x test

watch-check: ## 监听文件变化并检查代码
	cargo watch -x check

watch-clippy: ## 监听文件变化并运行 clippy
	cargo watch -x "clippy -- -D warnings"

# GraphQL 相关
graphql-schema: ## 导出 GraphQL Schema
	@echo "📋 导出 GraphQL Schema..."
	curl -X POST \
		-H "Content-Type: application/json" \
		-d '{"query": "query IntrospectionQuery { __schema { queryType { name } mutationType { name } subscriptionType { name } types { ...FullType } directives { name description locations args { ...InputValue } } } } fragment FullType on __Type { kind name description fields(includeDeprecated: true) { name description args { ...InputValue } type { ...TypeRef } isDeprecated deprecationReason } inputFields { ...InputValue } interfaces { ...TypeRef } enumValues(includeDeprecated: true) { name description isDeprecated deprecationReason } possibleTypes { ...TypeRef } } fragment InputValue on __InputValue { name description type { ...TypeRef } defaultValue } fragment TypeRef on __Type { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name } } } } } } } }"}' \
		http://localhost:3001/graphql > schema.json

# 版本管理
tag: ## 创建版本标签 (需要指定 VERSION)
	@if [ -z "$(VERSION)" ]; then echo "请指定版本: make tag VERSION=v1.0.0"; exit 1; fi
	git tag -a $(VERSION) -m "Release $(VERSION)"
	git push origin $(VERSION)

release: test lint fmt-check ## 准备发布 (运行所有检查)
	@echo "✅ 发布前检查通过"

# 监控和日志
logs: ## 查看应用日志
	tail -f logs/app.log

monitor: ## 启动监控 (如果配置了的话)
	@echo "📊 启动监控..."

# 统计
stats: ## 显示项目统计信息
	@echo "📊 项目统计:"
	@echo "代码行数:"
	@find src -name "*.rs" | xargs wc -l | tail -1
	@echo "文件数量:"
	@find src -name "*.rs" | wc -l
	@echo "依赖数量:"
	@grep -c "^[^#].*=" Cargo.toml || true

# 全套检查
full-check: clean build test lint fmt-check audit ## 运行完整的代码检查流程
	@echo "✅ 所有检查完成"

# 开发服务器 (包含数据库)
dev-full: docker-up dev ## 启动完整开发环境 (数据库 + 应用)
```

